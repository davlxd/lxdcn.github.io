<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>post.lxd.me</title>
   
   <link>https://post.lxd.me/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor>  </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Spring Data JPA Internals</title>
	  <link>//spring-data-jpa-internals-en</link>
	  <author> </author>
	  <pubDate>2017-03-22T20:34:56+08:00</pubDate>
	  <guid>//spring-data-jpa-internals-en</guid>
	  <description><![CDATA[
	     <p>In the previous post<sup>[<a href="/spring-introduction-en">1</a>]</sup>, I showed how brief it can be for Spring Data JPA to expose routine CRUD interfaces of simple database entities. This post goes a little bit further, by revealing the work Spring has done behind the scenes, and why we can interact with the database with the methods we declared in interfaces without implementing them.</p>

<p>I’m will start with Spring AOP.</p>

<h3 id="spring-aop-proxy">Spring AOP Proxy</h3>

<p>AOP (Aspect Oriented Programming) is a very common programming paradigm, it encapsulates logics and action from an another angle comparing to OOP(Object Oriented Programming). OOP encapsulates data and actions into classes, mostly correspond to domain models; but in runtime, it’s data flows from one module to another, so it’s more like a lot of chains consisting of business logics we wrote, and this is where AOP takes over. Let’s say normal method calling chains are vertical, then AOP cuts in from the horizontal angle, which encapsulates common logics like logging, auth, and cache etc into <code class="highlighter-rouge">aspect</code>s. And AOP also uses IoC<sup>[<a href="https://en.wikipedia.org/wiki/Inversion_of_control">2</a>]</sup> to make sure original code and logics remain intact while the extracted <code class="highlighter-rouge">aspect</code>s take all responsibilities.</p>

<p>AOP is capable of doing something like this: “Print a warning log to console for every java methods processing POST requests in all controllers”. Like I said the extracted entity doing the job is called <code class="highlighter-rouge">aspect</code>, the predicate describing “every java methods processing POST requests of all controllers” is called pointcut, and the action “print a warning log to console” is called <code class="highlighter-rouge">advice</code>.</p>

<p><code class="highlighter-rouge">AspectJ</code> is the founding predecessor of AOP in Java world, Spring AOP reuses some annotations, but implements on its own, and the core tech it uses is <code class="highlighter-rouge">AOP Proxy</code>. For example, we have an interface and one implementation called <code class="highlighter-rouge">SimplePojo</code>, calling <code class="highlighter-rouge">SimplePojo</code>’s <code class="highlighter-rouge">foo()</code> method looks like this:</p>

<p><img src="/assets/images/aop-proxy-plain-pojo-call.png" alt="Plain POJO call without Proxy" /></p>

<p>And if we create a proxy for <code class="highlighter-rouge">SimplePojo</code>, it looks like this:</p>

<p><img src="/assets/images/aop-proxy-call.png" alt="AOPproxy" />
(Both images come from Spring official documentation)</p>

<p>That being said, the proxy proxies the original method calling, and we can execute our <code class="highlighter-rouge">advice</code> inside the proxy. The following code demonstrates how to create a <code class="highlighter-rouge">proxy</code> with Spring AOP’s lower-level APIs.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">I</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">m</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"m in C"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="kd">extends</span> <span class="n">I</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">m</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">m2</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">proxyDemo</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ProxyFactory</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyFactory</span><span class="o">();</span>

        <span class="n">result</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="n">result</span><span class="o">.</span><span class="na">setInterfaces</span><span class="o">(</span><span class="n">I2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAdvice</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"m2"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"m2 in proxy"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">().</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">invoke</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">I2</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">I2</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m</span><span class="o">());</span>   <span class="c1">//Output: `m in C'</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m2</span><span class="o">());</span>  <span class="c1">//Output: `m2 in proxy'</span>
    <span class="o">}</span></code></pre></figure>

<p>Here are explanations:
- I declared an interface <code class="highlighter-rouge">I</code>
- I defined a class <code class="highlighter-rouge">C</code> inheriting interface <code class="highlighter-rouge">I</code>, and within which I also defined a method <code class="highlighter-rouge">m</code>
- Interface <code class="highlighter-rouge">I2</code> inherits interface <code class="highlighter-rouge">I</code>, and I declared 2 methods (<code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">m2</code>) in it
- <code class="highlighter-rouge">ProxyFactory</code> is Spring AOP’s factory class for proxy. I instantiated it, set its target to an object of <code class="highlighter-rouge">C</code>, set proxied interface to <code class="highlighter-rouge">I2</code>, and added a method interceptor
- <code class="highlighter-rouge">MethodInterceptor</code> is an interface, the overridden method <code class="highlighter-rouge">invoke</code> does the actual work, which in our case are: a) intercepts method call to <code class="highlighter-rouge">m2</code>, return String <code class="highlighter-rouge">m2 in proxy</code>, and b) redirects all other method call (just <code class="highlighter-rouge">m</code> in our case) to the target (a <code class="highlighter-rouge">C</code> object in our case)</p>

<p><br />
After a brief introduction to Spring AOP proxy, now I can partly answer the question I asked in the beginning: why we can call methods we declared in interfaces without implementations? Actually the demo above is a simplified version of Spring Data JPA implementation.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>For Spring Data JPA, when we declare an interface like above, Spring firstly creates a bean named <code class="highlighter-rouge">itemRepository</code>, and it, of course, is a proxy, which is initialized and configured in <code class="highlighter-rouge">RepositoryFactorySupport</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177">3</a>]</sup>. The <code class="highlighter-rouge">target</code> of this proxy is <code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java">4</a>]</sup>, it contains basic CRUD methods like <code class="highlighter-rouge">save()</code>, and <code class="highlighter-rouge">delete()</code> etc by using <code class="highlighter-rouge">EntityManager</code>. The proxied interfaces are <code class="highlighter-rouge">ItemRepository</code> and <code class="highlighter-rouge">Repository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190">5</a>]</sup>. There are multiple method interceptors in the proxy, the one deal with Query Method is <a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375">this one</a>, what it does is iterating all query methods in <code class="highlighter-rouge">ItemRepository</code>, creating a <code class="highlighter-rouge">RepositoryQuery</code> object for each of them and add to a map<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415">7</a>]</sup>.</p>

<p>Once our code invoke <code class="highlighter-rouge">itemRepository.findByName()</code>, the thread immediately goes into <code class="highlighter-rouge">invoke</code> method of the method interceptor<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438">8</a>]</sup>. The interceptor judges if the method we are calling is query method<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">9</a>]</sup> at first, if it is, fetch <code class="highlighter-rouge">RepositoryQuery</code> and execute with parameters, otherwise just call corresponding methods in <code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467">10</a>]</sup>.</p>

<h3 id="mini-parser">Mini Parser</h3>

<p>Now let’s move on to the 2nd part of the question: how does Spring find out our intention and complement implementation details only by the declared method name <code class="highlighter-rouge">findByName</code>?</p>

<p>It’s not magic at all if we take a deeper thought into it, since we need to comply to certain rules when composing query methods<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">11</a>]</sup>, the exact same rules which can be used by Spring to parse and generate JPA query objects. The entry point for parsing is here<sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95">12</a>]</sup>, and the  object generated to interact with database is <code class="highlighter-rouge">RepositoryQuery</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415">7</a>]</sup>.</p>

<p>This mini parser is a hand-written, top-down parser, nothing fancy, no BNF expressions, no parser generators. The topmost node class is <code class="highlighter-rouge">PartTree</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76">13</a>]</sup>, which contains 2 child nodes <code class="highlighter-rouge">subject</code> and <code class="highlighter-rouge">predict</code>. <code class="highlighter-rouge">subject</code> represents query results you want, and <code class="highlighter-rouge">predicate</code> represents conditions just like what it means. For <code class="highlighter-rouge">findByName</code>, <code class="highlighter-rouge">subject</code> is empty and <code class="highlighter-rouge">predicate</code> is <code class="highlighter-rouge">Name</code>; and for more complicated one like <code class="highlighter-rouge">findDistinctUserByNameOrderByAge</code>, subject is <code class="highlighter-rouge">DistinctUser</code> while predicate is <code class="highlighter-rouge">NameOrderByAge</code>.</p>

<p><code class="highlighter-rouge">Subject</code> class has 3 boolean fields: <code class="highlighter-rouge">distinct</code>, <code class="highlighter-rouge">count</code>, <code class="highlighter-rouge">delete</code>, and a integer field <code class="highlighter-rouge">maxResults</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275">14</a>]</sup>. <code class="highlighter-rouge">query</code> is true if query method starts with <code class="highlighter-rouge">findDistinct</code>, count methods set <code class="highlighter-rouge">count</code> to true, the same for <code class="highlighter-rouge">delete</code>, and <code class="highlighter-rouge">maxResults</code> holds the value for limiting queries like <code class="highlighter-rouge">findFirst10ByLastname</code>.</p>

<p><code class="highlighter-rouge">Predicate</code> has an ArrayList <code class="highlighter-rouge">nodes</code> which contains all <code class="highlighter-rouge">OrPart</code> nodes for query method name split by <code class="highlighter-rouge">Or</code>, as you can see this is how and-or-precedence implemented. And there is also an <code class="highlighter-rouge">orderBySource</code> node contains sorting nodes<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L342">15</a>]</sup>.</p>

<p>I am not going further, since it’s just trivial parser implementations. And this is the AST for a relatively long query method <code class="highlighter-rouge">findDistinctByStateAndCountryLikeOrMapAllIgnoringCaseOrderByNameDesc</code>:</p>

<p><img src="/assets/images/ast-of-a-long-query-method.png" alt="AST of a long Query Method" /></p>

<p>Once Spring has the AST, Spring Data will call JPA interfaces to create objects like <code class="highlighter-rouge">Predicate</code> and <code class="highlighter-rouge">CriteriaQuery</code>, then hand them over to JPA to query the database<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98">16</a>]</sup>.</p>

<p>The rules and the parser are extremely simple and crude, ambiguities are very common, nonetheless, it’s totally acceptable since it’s just a helping tool. If ambiguous situations occur, just rename the field name, or, use named query<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries">17</a>]</sup> instead.</p>

<h3 id="references">References</h3>

<ul>
  <li>[1]https://post.lxd.me/2017-03-17-spring-introduction-en/</li>
  <li>[2]https://en.wikipedia.org/wiki/Inversion_of_control</li>
  <li>[3]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177</li>
  <li>[4]https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java</li>
  <li>[5]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190</li>
  <li>[6]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375</li>
  <li>[7]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415</li>
  <li>[8]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438</li>
  <li>[9]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[10](https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467</li>
  <li>[11]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[12]https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95</li>
  <li>[13]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76</li>
  <li>[14]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275</li>
  <li>[15]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L342</li>
  <li>[16](https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98</li>
  <li>[17]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Spring Data JPA 技术分析</title>
	  <link>//spring-data-jpa-internals</link>
	  <author> </author>
	  <pubDate>2015-12-07T20:34:56+08:00</pubDate>
	  <guid>//spring-data-jpa-internals</guid>
	  <description><![CDATA[
	     <p>在另一篇介绍Spring的文章<sup>[<a href="/spring-introduction">1</a>]</sup>里我介绍了Spring Data JPA，借助Spring Data JPA，对数据库做CRUD需要简单的四步操作：先创建数据库表和Java entity类；声明一个接口<code class="highlighter-rouge">ItemRepository</code>继承<code class="highlighter-rouge">CrudRepository</code>；再在接口<code class="highlighter-rouge">ItemRepository</code>里声明Query Method<code class="highlighter-rouge">findByName</code>；最后把<code class="highlighter-rouge">ItemRepository</code>注入到我们需要用到的地方，调用就可以了。</p>

<p>这篇文章再深入一点，解释/分析一下Spring在背后做了什么；为什么作为一个Spring用户，我们声明一个接口，在接口里声明一个方法，我们就可以调用这个方法了操作数据库了？</p>

<p>先从Spring AOP说起。</p>

<h3 id="spring-aop-proxy">Spring AOP Proxy</h3>

<p>AOP（面向切面编程，Aspect-Oriented Programming），是Java里常用的一个编程范式。OOP对逻辑和数据做了一定程度的封装，但是当应用运行起来之后，从数据流的角度来看，数据是从一个类实例流到另一个实例，是链式的，我们编写的业务逻辑也是在一条条调用链上做文章。而AOP则是从另一个维度做文章：比如说原来的模块划分，或者调用链是纵向的，那么AOP是从横向切入，把纵向维度中共性的部分，比如logging、auth、cache，抽取出来，并且用IoC<sup>[<a href="https://en.wikipedia.org/wiki/Inversion_of_control">2</a>]</sup>的思想，由抽取出来的<code class="highlighter-rouge">aspect</code>承担匹配和执行的责任，原来的业务逻辑不需要添加/改动任何代码。</p>

<p>举例来说，AOP可以做这样的事情：“让一个Web应用中所有Controller的POST方法执行之前打一条log”。抽取出来做这件事情的模块称为<code class="highlighter-rouge">aspect</code>，描述匹配到“所有Controller的POST方法”的谓词称为<code class="highlighter-rouge">pointcut</code>，“打log”这样的行为称为<code class="highlighter-rouge">advice</code>。</p>

<p>AspectJ是这个Java里AOP鼻祖老爷，Spring AOP兼容了一部分AspectJ的annotation，但核心还是Spring自己的，这个核心就是AOP proxy。比如我们有一个接口<code class="highlighter-rouge">Pojo</code>和它的实现<code class="highlighter-rouge">SimplePojo</code>，当没有proxy的时候，调用<code class="highlighter-rouge">SimplePojo</code>的<code class="highlighter-rouge">foo</code>方法是这样的：</p>

<p><img src="/assets/images/aop-proxy-plain-pojo-call.png" alt="Plain POJO call without Proxy" /></p>

<p>当我们创建一个<code class="highlighter-rouge">SimplePojo</code>的proxy之后，调用这个proxy的<code class="highlighter-rouge">foo</code>方法的是这样的：</p>

<p><img src="/assets/images/aop-proxy-call.png" alt="AOPproxy" />
（两张图片都来自Spring官方文档）</p>

<p>即proxy“代理”了对原对象原方法的调用，在这个代理的过程中我们可以执行<code class="highlighter-rouge">advice</code>，比如Spring AOP中的方法拦截器。下面的代码演示了如何用Spring AOP的底层API创建一个proxy。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">I</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">m</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"m in C"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="kd">extends</span> <span class="n">I</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">m</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">m2</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">proxyDemo</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ProxyFactory</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyFactory</span><span class="o">();</span>

        <span class="n">result</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="n">result</span><span class="o">.</span><span class="na">setInterfaces</span><span class="o">(</span><span class="n">I2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAdvice</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"m2"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"m2 in proxy"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">().</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">invoke</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">I2</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">I2</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m</span><span class="o">());</span>   <span class="c1">//Output: `m in C'</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m2</span><span class="o">());</span>  <span class="c1">//Output: `m2 in proxy'</span>
    <span class="o">}</span></code></pre></figure>

<p>首先声明一个接口<code class="highlighter-rouge">I</code>；类<code class="highlighter-rouge">C</code>实现接口<code class="highlighter-rouge">I</code>的同时自己定义了一个方法<code class="highlighter-rouge">m()</code>；接口<code class="highlighter-rouge">I2</code>继承<code class="highlighter-rouge">I</code>并声明了方法<code class="highlighter-rouge">m()</code>和方法<code class="highlighter-rouge">m2()</code>。ProxyFactory是Spring AOP的proxy工厂类，实例化之后，设置proxy的target为<code class="highlighter-rouge">C</code>的实例，要代理的接口为<code class="highlighter-rouge">I2</code>，然后添加一个方法拦截器。</p>

<p>方法拦截器是一个接口，我们实例化的匿名内部类的<code class="highlighter-rouge">invoke()</code>方法就是这个拦截器的回调。当调用的方法名字是<code class="highlighter-rouge">m2</code>的时候，拦截器直接返回一个字符串<code class="highlighter-rouge">m2 in proxy</code>。当调用的方法名字是<code class="highlighter-rouge">m</code>的时候，通过反射获取到target（<code class="highlighter-rouge">C</code>的实例）的<code class="highlighter-rouge">m()</code>方法，调用执行。
<br />
介绍了Spring AOP Proxy之后，就可以解释一开始那个问题的前半部分了——为什么在我们只声明了一个接口和方法的情况下，这个方法可以被调用到？事实上上面的demo已经基本上了回答了这个问题，接下来我把各部分逻辑对应到Spring Data JPA上。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Spring在创建的名为<code class="highlighter-rouge">itemRepository</code>的bean，就是一个proxy，这个proxy在<code class="highlighter-rouge">RepositoryFactorySupport</code>里完成了初始化和配置<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177">3</a>]</sup>；Proxy的target是<code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java">4</a>]</sup>，它用<code class="highlighter-rouge">EntityManager</code>实现了<code class="highlighter-rouge">CrudRepository</code>里的基本CRUD方法；Proxy的代理接口即<code class="highlighter-rouge">ItemRepository</code>和<code class="highlighter-rouge">Repository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190">5</a>]</sup>；Proxy添加了多个方法拦截器，处理自定义Query Method的拦截器是<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375">6</a>]</sup>，这个拦截器在构造函数里遍历<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象放到一个map中<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>。</p>

<p>当我们的代码调用到<code class="highlighter-rouge">itemRepository.findByName()</code>的时候，即进入到方法拦截器的<code class="highlighter-rouge">invoke</code>方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438">8</a>]</sup>，拦截器首先判断是不是Query Method<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">9</a>]</sup>，如果是的话就取出<code class="highlighter-rouge">RepositoryQuery</code>对象带参数执行，不是的话调用<code class="highlighter-rouge">SimpleJpaRepository</code>里的方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467">10</a>]</sup>。</p>

<h3 id="mini-parser">Mini Parser</h3>

<p>下面接着继续分析开题问题的第二部分，为什么我们只声明一个<code class="highlighter-rouge">findByName</code>的方法，Spring就知道如何去查询数据库了？</p>

<p>事实上细细想来这个并不特别神奇，我们在声明query methods的时候，是需要遵循规范的<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">11</a>]</sup>，既然我们定义方法遵循了规范，Spring基于同样的规范，用一个parser解析这个方法名，就能生成JPA的查询对象。</p>

<p>我们在前面提到Spring会根据<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>，这个对象就是一个迷你的parser解析query method方法名的结果，解析的入口在<sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95">12</a>]</sup>。</p>

<p>这个mini parser是自顶向下解析的，最顶上的节点类是<code class="highlighter-rouge">PartTree</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76">13</a>]</sup>，它包含两个字段/子节点，<code class="highlighter-rouge">subject</code>和<code class="highlighter-rouge">predicate</code>。<code class="highlighter-rouge">subject</code>表示要查询的结果，<code class="highlighter-rouge">predicate</code>表示查询的条件。比如对于<code class="highlighter-rouge">findByName</code>，<code class="highlighter-rouge">subject</code>为空，<code class="highlighter-rouge">predicate</code>为<code class="highlighter-rouge">Name</code>；再比如稍微复杂一点的<code class="highlighter-rouge">findDistinctUserByNameOrderByAge</code>，subject是<code class="highlighter-rouge">DistinctUser</code>，predicate是<code class="highlighter-rouge">NameOrderByAge</code>。</p>

<p><code class="highlighter-rouge">Subject</code>有3个boolean属性，分别是<code class="highlighter-rouge">distinct</code>，<code class="highlighter-rouge">count</code>，<code class="highlighter-rouge">delete</code>，<code class="highlighter-rouge">maxResults</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275">14</a>]</sup>，如果query带了<code class="highlighter-rouge">Distinct</code><code class="highlighter-rouge">distinct</code>就是true，count方法<code class="highlighter-rouge">count</code>为true，delete方法<code class="highlighter-rouge">delete</code>为true。<code class="highlighter-rouge">maxResults</code>是limit查询的值，如<code class="highlighter-rouge">findFirst10ByLastname</code>。</p>

<p><code class="highlighter-rouge">Predicate</code>有一个ArrayList<code class="highlighter-rouge">nodes</code>包含以<code class="highlighter-rouge">Or</code>split后的节点<code class="highlighter-rouge">OrPart</code>，还有一个<code class="highlighter-rouge">orderBySource</code>包含用<code class="highlighter-rouge">OrderBy</code>split的排序节点<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345">15</a>]</sup>。</p>

<p>……</p>

<p><code class="highlighter-rouge">OrPart</code>节点往后不再赘述推导规则了，最后，定义一个比较复杂的方法看一下AST。对于<code class="highlighter-rouge">findDistinctByStateAndCountryLikeOrMapAllIgnoringCaseOrderByNameDesc</code>，AST如下图</p>

<p><img src="/assets/images/ast-of-a-long-query-method.png" alt="AST of a long Query Method" /></p>

<p>有了AST之后，Spring Data再调用JPA的接口创建<code class="highlighter-rouge">Predicate</code>对象、<code class="highlighter-rouge">CriteriaQuery</code>对象等，交给JPA查询DB<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98">16</a>]</sup>。</p>

<p>这个规则和parser都很简陋，很容易出现二义的情况，如果遇到这样的情况，就不一定非要苦苦纠结于解析规则了，它目的毕竟还是为了给用户提供方便，如果不能很方便的提供方便，那就给字段改个名儿，或者改用Named Query<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries">17</a>]</sup>。</p>

<p><br /><br /></p>

<p>参考资料：</p>

<ul>
  <li>http://docs.spring.io/spring-data/jpa/docs/current/reference/html/</li>
  <li>http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html</li>
  <li>[1]http://post.lxd.me/2015-12-01-spring-introduction/</li>
  <li>[2]（控制反转的思想，不特指Spring DI） https://en.wikipedia.org/wiki/Inversion_of_control</li>
  <li>[3]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177</li>
  <li>[4]https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java</li>
  <li>[5]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190</li>
  <li>[6]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375</li>
  <li>[7]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[8]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438</li>
  <li>[9]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[10]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467</li>
  <li>[11]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[12]https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95</li>
  <li>[13]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76</li>
  <li>[14]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275</li>
  <li>[15]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345</li>
  <li>[17]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries</li>
  <li>[16]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98</li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
