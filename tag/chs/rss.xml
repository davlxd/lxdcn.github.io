<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>post.lxd.me</title>
   
   <link>https://post.lxd.me/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor>  </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>分裂</title>
	  <link>//disorder</link>
	  <author> </author>
	  <pubDate>2017-02-09T05:05:00+08:00</pubDate>
	  <guid>//disorder</guid>
	  <description><![CDATA[
	     <p>老李躺在沙发上，有点紧张，对面的张医生看起来挺年轻的，也不知道行不行。老婆小琳陪着一起过来的，正坐在外面等。理论上的老婆，老李默默的想，可别折腾太久了啊。</p>

<p>“您的这个症状什么时候开始出现的？”，张医生先发话了。</p>

<p>“嗯……要不……我从头开始讲？”</p>

<p>“可以。”</p>

<p><br /></p>

<p>事情是从三个半月前开始的，当时老李赶上一个大项目，不巧手下的得力干将又离职了四个，大大小小的事情就都压在他身上了。老李一忙就烦躁，烦躁了就控制不住自己的脾气了，特别容易发火。其实老李是个好人，每次发完火心里也觉得很愧疚，但是心里浮躁，就是控制不住自己。最让老李郁闷的是，因为工作上的事情占用了太多精力，再加上烦躁，每天回家之后对老婆孩子也有点不耐烦了，他越想越着急，心理压力更大。</p>

<p>有一天，因为下水管出了一点问题，老婆打电话过来请示，他洋洋洒洒的抱怨了三十来分钟，挂了电话想了想又后悔了，唉声叹气的摇了摇头，揉揉眼睛准备继续工作，坐在隔壁工位的老王探过脑袋关切的问道：</p>

<p>“感觉对不住弟妹？”</p>

<p>“是啊！我这两天九九六，本来陪老婆的时间就少，回家之后还烦躁的很，特别容易上火。”</p>

<p>“嗯。”</p>

<p>“虽然小琳体谅我，也从不说什么，但感觉还是很愧疚。”</p>

<p>“嗯，理解。”</p>

<p>“也不知道什么时候才能熬到头啊，老王你说我是不是不适合干这个，要不还是回学校教书去算了。”</p>

<p>“你可千万别这样想，其实大家伙儿都这样，表面上光鲜，苦水只能往自个儿肚子里咽。你看赵总，你知道他每天睡几个小时么？”</p>

<p>“我可比不了他，起码这辈子不行。哎老王，我看你就挺厉害啊，再忙的事儿也不着急不上火。”</p>

<p>“呵呵，其实啊，我年轻的时候，也这样，后来受高人指点，找对了门路，就顺了。”</p>

<p>“什么门路？”</p>

<p>“工作上的事儿，和家里的事儿，要分得开。”</p>

<p>“这个我也听说过，也试过，但就是控制不住。工作、家庭，哪有那么容易分得开。而且每天除去睡觉吃饭就剩那么十来个小时，要么忙着工作，要么得顾着家里，这就是零和游戏啊。”</p>

<p>“所以你没找对门路嘛，这要害就是，你下班了回家之后，完全不要想白天工作相关的事儿，任何电话都不管它，邮件也不回。白天上班了之后，也不要惦记家里的事儿，让你老婆白天不要给你打电话。”</p>

<p>“感觉也没什么要害啊。”</p>

<p>“不不不，你要做到完全不想，完全不理。比如现在，专心工作，就当你自个儿还没结婚呢；回家之后，别再操心工作上的事情，让工作这俩字从你的记忆里消失！”</p>

<p>“完全不想？”</p>

<p>“对，完全不想！”</p>

<p>“我琢磨琢磨。”</p>

<p><br /></p>

<p>从善如流是老李为人做事这么多年历练出来的一个特点，他决定照着老王的说法试试。一开始也觉得别扭，但是忍了几日之后就慢慢感觉到好处了。白天心无旁骛的工作，效率高了不少；而下班回家之后，在进门的刹那，就真的跟电视换台一样，一下子把所有跟工作相关的事情全部抛诸脑后，自己轻松许多，小琳脸上的笑容也明显变多了。</p>

<p>工作和生活都慢慢走向了正轨，老李心里的石头也就慢慢放下了，内心重回平和和喜悦，直到十来天之后，他开始慢慢觉得有点不大对劲了。有天晚上他在家里陪老婆看电视，老王打电话过来叫他出去喝酒，他想了好一阵子，才想起来老王是谁，仿佛好久没联系的老友似的，这不白天上班刚见过面么，老李心里犯嘀咕。跟老婆说了一声，老李打了个滴滴直奔那家饭馆。到了那家馆子，一进门，老远就看见一张熟悉的面孔坐在一张小桌子边上，桌子上摆了四五盘菜，还有两瓶百威。那是老王没错，老李心里松了口气，正好老王在冲他招手，他就赶紧过去，落了坐，一起喝上了。</p>

<p>第二天上班，老李先到了，他先跟一个客户打了个电话，刚打完，就瞥见老王哼着小曲儿进了办公室。老王刚把包放下，就探过脑袋笑眯眯的问道：</p>

<p>“昨儿晚上喝的还行吧？”</p>

<p>“昨天晚上……嗯？……什么？”</p>

<p>一瞬间，腾的一下，老李感觉全身的血都涌到脑袋上去了，昨天晚上喝酒的事情，他隐约记得有这么回事，但是完全想不起来了，这种感觉很熟悉，不是第一次发生了，但是上一次是什么事情也完全想不起来了。老李瘫倒在椅子上，吓了老王一跳。</p>

<p>“我操，老李，你怎么了？没事儿吧？”</p>

<p>老李定了定神，从恍惚中稍微缓过点气儿来。</p>

<p>“没事……我没事，让我一个人静静。”</p>

<p>“你确定没事儿？”</p>

<p>“我确定，你先忙吧，我一个人坐会儿。”</p>

<p>老王端详了会儿，确定老李没什么大碍，也不好再问什么，就忙他的去了。老李瘫着坐了十来分钟，终于慢慢想起来昨天晚上和老李喝酒的事情，也慢慢想起来昨天晚上老王跟他打电话，他半天想不起来老王是谁的事情了。也就是说，老李白天想不起晚上的事情，晚上想不起白天的事情了，换句话说，他工作的时候，想不起在家里发生的事情，在家的时候，记不起在公司的事情了——就跟老王之前传授给他的门路一样，不过这次成真的了。</p>

<p>老李艰难的坐起来，走到老王身边，把他现在的症状和推论跟老王描述了一遍。</p>

<p>“我操！这不可能！哪能这么灵呐，完全一点都想不起来啦？”</p>

<p>“很模糊，使劲想使劲想能想起来，但是很费力。这个方法，这个门路是你最开始教给我的，你没有这个问题？”</p>

<p>“没有啊！必须没有啊！我那是说刻意别去想，可没说直接给忘了啊！你这已经分裂了，就跟那个啥，精神分裂症一样，24个比利那种。”</p>

<p>听见精神分裂症几个字，老李有点不爽，但更多的是害怕。他慢慢走回自己的位子上，决定再过两天看看，兴许是最近睡眠质量的问题，人怎么可能无缘无故就精神分裂了呢，老李摇摇头。</p>

<p>然而情况并没有好转，反而更差了，记忆更模糊了。之前使劲使劲想四五分钟还能想起来，现在需要十来分钟，有时候甚至完全想不起来了。于是小琳帮忙联系了张医生，请了一天假，专门陪着过来了。</p>

<p><br /></p>

<p>“那您在白天的话，晚上相关的任何事情都想不起来了？还是特定的事物，或者特定的场景？”</p>

<p>“所有的事情，所有相关的事情。”</p>

<p>“那坐在外面的，您爱人……”</p>

<p>老李苦笑了一下，摇摇头。</p>

<p>“是这样的，您的这个症状，既不属于精神分裂症，也不属于24个比利的多重性人格症，这两个不是一回事。精神分裂症，主要是会出现幻觉，受迫害的妄想，以及思维和言语紊乱。而多重性人格症，也叫解离性身份障碍，是指有多个人格存在于一个身体，但每一个人格都是稳定、发展完整、拥有各别思考模式和记忆。您的这个症状，主要是遗忘，跟两者都有点像，但是都不属于，至于是什么病症，我也不知道，很抱歉，我无能为力。”</p>

<p>老李惊讶的抬起头。</p>

<p>“那就一点办法都没有？”</p>

<p>“很抱歉。”</p>

<p>看着张医生坚定的眼神，明明白白的写着送客两个字，老李失落极了。他摇摇头，站起来，转身打开门走出去了，出门正好对上小琳抬起头的目光，老李心里不是滋味，轻轻的摇了摇头，然后两人一起离开了。</p>

<p><br /></p>

<p>老李躺在躺椅上，享受着冬日温暖的阳光，身旁忙碌穿梭的护工，和不远处狂叫、嘶吼的病患丝毫不影响他的兴致。他是整个疗养院为数不多不需要服药，不需要护工特别照看的病人，大家对他印象也很好，因为除了吃喝拉撒，他每天大部分时间都躺在椅子上一动不动。那天被张医生判了死刑之后，小琳又陆续找了几个医生，但都没有办法，而老李的情况却越来越糟了。从最开始白天晚上分裂，慢慢的上午下午开始分裂，到最后他只要一恍神就会分裂，已经完全没有办法连贯的思维了。来到这儿之后，他的思维大部分时间都处在混沌之中，前一秒的思绪像野马一样奔腾，后一秒什么都想不起来了。有时候他的大脑一片空白，没有任何记忆和思绪的波动。有时候他在梦境和现实之间自由的穿梭游走，到最后完全分不清梦境和现实。但有时候连贯的思维能持续一上午，甚至一整天，这时候他便能记起所有发生过的事情，这时候的他就像上帝一样在记忆的宫殿里观察另一个自己，他看到张医生告诉他无能为力时他脸上绝望的表情，他看到自己病情持续恶化，最后不得不被老王和小琳送进这家疗养院，他看到小琳每个月都会到这里来看他，而他每次只是漠然的对她礼貌性的笑笑。有时候他甚至能看到未来，他看到自己头鬓斑白的躺在另一个疗养院，因为这个疗养院十七年之后关停了。他突然感到一阵头晕，不知道下一秒会发生什么。</p>

	  ]]></description>
	</item>

	<item>
	  <title>“呵呵，其实我也是一个内向的人”</title>
	  <link>//introvert-life</link>
	  <author> </author>
	  <pubDate>2016-12-18T23:28:24+08:00</pubDate>
	  <guid>//introvert-life</guid>
	  <description><![CDATA[
	     <p>小李今年刚毕业，虽说之前在公司实习的时候积累了一些工作经验，但是小李生性谨慎，谨小慎微，虽然前两天已经提前转正，成为正式员工了，但做事情还是战战兢兢，诚惶诚恐，谨遵老父亲叮嘱的“少说话，多做事，尊重领导，团结同事”的家训。</p>

<p>一日，领导找到小李谈心，小李就更紧张了，一边往小会议室去的路上，一边过电影一般回想了一下从入职到现在的工作，有没有出现纰漏，犯过什么错误——得出否定的答案之后，小李稍稍松了口气，假装镇定的坐在领导对面，等着领导先说话。</p>

<p>领导先笑了一下，开始说起公司最近业务上的一些瓶颈和发展策略。小李特佩服领导这种特别能讲的老员工，小李刚到公司参加新员工培训的时候，领导有过一次讲演，当时的主题是《如何在一个煎饼果子里夹二十个鸡蛋而不使炸裂》，慷慨激昂，气动山河，既有理论又有深度，简直跟乔布斯一样有范儿，哦不，比乔布斯还有范儿，他做梦也想成为领导这样的人。这时，领导顿了顿，微笑的看着小李，小李有点慌。</p>

<p>“小李啊，我发现你还挺内向的。”</p>

<p>“嗯”</p>

<p>“呵呵，其实我也是我也是一个内向的人。”</p>

<p>小李的脑子里轰的炸开了！啊？！怎么可能，领导如此口吐莲花，并且在公司混的如鱼得水，年纪轻轻就已经是部门主管，怎么会是一个内向的人。倘若真是，那领导这是经历了多少内心的磨难，克服了多少障碍，才取得了今天这样的成就啊。不知怎的，小李觉得心里暖洋洋的，和领导的关系也亲近了不少。</p>

<p>但是领导话锋一转，说，“但是小李啊，你还是太内向了啊，你手头的工作可能还是不太适合你，你先去基层锻炼锻炼吧。”</p>

<p><br />
小李在基层一待，就是十年，从开始大家喊他小李，也慢慢变成了老李。因为经常需要亲临现场指导工作，要搞好群众关系，老李被逼着慢慢的也会说话了，有时候站在台上对着下面两百多号人也能讲个一两分钟不打怵。有时候也需要跟新来的下基层的新同事谈心，对于那些特别内向的，就像他的老领导一样，他每次都会先呵呵一下，然后以“其实我也是我也是一个内向的人”开场，每次，都能从他们的眼中看出闪动着的夹杂着困惑和激动的光芒，老李每次看到这种光芒，都会一阵欣慰，一阵心酸，然而接下来的谈心，也就格外顺利。</p>

<p>功夫不负有心人，在基层第十一年零第三个月的时候，老李瞅准了一个机会，黑了一把，终于又回到了总公司。</p>

<p><br />
回总公司之后，生活上，工作上，都顺风顺水，之前一直拖着的婚事也立马就敲定了，不出一年，就生了个大胖小子。</p>

<p>老李老来得子，儿子自然是天天捧在手心里，要什么给什么。可是说来也怪，也许是基因方面的原因，儿子也是一个特别内向的人，家里来客人了都躲在屋子里不敢出来，好不容易轰出来了也是半天放不出一个屁，叫声叔叔阿姨好就红着脸急急忙忙的走开了，每次都搞得老李很郁闷。</p>

<p>这天，儿子放学之后，躲在屋子里呜呜哭，老李不知为何，问老婆，原来是儿子在学校又被欺负了——这是第三次转学的第十一次了。这天家里没客人，老婆便把儿子从屋子里劝出来，摆了一堆零食甜点哄儿子，然后自个儿回厨房打算做顿大餐，边做饭边安慰儿子。</p>

<p>老李在客厅边喝茶边看报纸，一开始觉得儿子可怜，可后来越听越气，越想越怒，一把把茶壶在地上摔个粉碎，指着儿子骂道：“你个脓包！老子怎么养你这么个玩意儿！！看你这副怂样儿，将来能有什么出息！！！”，说罢冲过去举起手就要煽儿子。</p>

<p>老婆在厨房忙活来不及出来，一边提着菜刀往客厅跑，一边尖叫着骂道：“你要是敢打儿子，我就跟你拼命！！！儿子是怂包，你不是怂包吗？！你们老李家祖祖辈辈都是怂包！”</p>

<p>老李举起来的手僵住了，一瞬间，从刚参加工作开始的种种，像过电影一般从眼前历历闪过，老李不由得老泪纵横，但一想到世道艰难，一狠心，举起的手还是落下去了，“啪！”。</p>


	  ]]></description>
	</item>

	<item>
	  <title>受限环境中的奇淫技巧之 — ssh通道</title>
	  <link>//ssh-tunnel-in-restricted-env</link>
	  <author> </author>
	  <pubDate>2016-08-15T20:34:56+08:00</pubDate>
	  <guid>//ssh-tunnel-in-restricted-env</guid>
	  <description><![CDATA[
	     <h3 id="ssh-">ssh 端口转发</h3>
<p>先复习一下基础知识，ssh 端口转发（ssh Port Forwarding），也叫ssh通道（ssh tunnel），是openSSH提供的~~中国~~特色功能。它的功能，是在一条已经建立的ssh连接的基础上，将对本地端口的请求，经由ssh，通过ssh server转发到另外一台服务器；或者对ssh server端口的请求经由ssh，通过本地机器转发到另外一台服务器。它有3种：</p>

<ul>
  <li>ssh本地端口转发（Local port forwarding）</li>
  <li>ssh远端端口转发（Remote port forwarding）</li>
  <li>ssh动态端口转发（Dynamic port forwarding）</li>
</ul>

<p>假定有一个程序员叫Alice，她有一台笔记本（laptop），还有一个在云提供商上的Linux server（workstation），她平时ssh连接到workstation上是这样操作的：<code class="highlighter-rouge">[alice@laptop ~] $ ssh -p 22 alice@workstation</code> —— Alice在她的笔记本（laptop）上，用ssh默认端口22，连接到她的workstation上。</p>

<p><strong>ssh本地端口转发</strong>，是将Alice对laptop的某个端口的TCP请求，通过ssh，经由workstation，转发到另外一台server的特定端口上，靠ssh的<code class="highlighter-rouge">-L</code>开关 ，命令是这样的：<code class="highlighter-rouge">[alice@laptop ~] $ ssh -L 3000:server:4000 -p 22 alice@workstation</code>。如是，Alice在laptop上访问3000端口，就相当于<u>在workstation上访问server的4000端口</u>。比如有个HTTP服务Alice在laptop上访问不到，但是可以在workstation上访问到，借助<code class="highlighter-rouge">ssh -L 8080:server:80 -p 22 alice@workstation</code>本地端口转发，Alice在laptop上用浏览器访问<code class="highlighter-rouge">http://localhost:8080</code>，相当于在workstation上访问<code class="highlighter-rouge">http://server</code>。</p>

<p>再比如Alice还有一台更早的Linux server，但由于常年用来翻墙，已经被功夫网封禁掉了（就叫workstation_blocked），除了先手动ssh到workstation上再ssh到workstation_blocked上之外，她还可以先执行：<code class="highlighter-rouge">[alice@laptop ~] $ ssh -L 2000:workstation_blocked:22 alice@workstation</code>，然后每次需要访问workstation_blocked的时候执行<code class="highlighter-rouge">[alice@laptop ~] $ ssh alice@localhost -p 2000</code>就可以了。——这个就是ssh中继（ssh relay）。</p>

<p><strong>ssh远端端口转发</strong>，和本地端口转发相反。Alice建立了ssh连接之后，使得对workstation上某个端口的TCP访问，经由ssh，通过laptop，转发到另外一台server上。靠的是ssh的<code class="highlighter-rouge">-R</code>开关，命令是这样的：<code class="highlighter-rouge">[alice@laptop ~] $ ssh -R 3000:server:4000 -p 22 alice@workstation</code>。如是，Alice在workstation上访问3000端口，就相当于在laptop上访问server的4000端口。</p>

<p>无论是本地端口转发还是远端端口转发，server都可以是localhost，这个对远端端口转发来说就很有用。比如有这样的场景：Alice的laptop平时搁家里，连无线路由Wi-Fi上网，Alice在公司上班的时候，忙里偷闲，想通过公司的PC访问远在家里的laptop怎么办？首先，Alice在早上上班出门前需要先在laptop上用ssh连接到workstation上，打开远端端口转发到laptop的22端口：<code class="highlighter-rouge">[alice@laptop ~] $ ssh -R 2000:localhost:22 -p 22 alice@workstation</code>，这样，在workstation上对2000端口的TCP连接，都会经由ssh，通过laptop，转发到laptop本身（localhost）的22端口上。然后她在公司的PC上，先ssh普通连接到workstation，再<code class="highlighter-rouge">[alice@workstation ~] $ ssh -p 2000 alice@localhost</code>，就可以偷闲了。</p>

<p><strong>ssh动态端口转发</strong>，即在ssh连接上开启一个SOCKS的代理端口，是翻墙3大法器（VPN、HTTP Proxy、SOCKS Proxy）中SOCKS Proxy的ssh分支。命令是<code class="highlighter-rouge">[alice@laptop ~] $ ssh -D 1080 -C -p 22 alice@server_ip</code>，然后在浏览器中设置SOCKS代理到127.0.0.1，1080端口，即可翻墙。</p>

<p>openSSH还提供了两个开关可以结合端口转发使用，<code class="highlighter-rouge">-N</code>在ssh连接成功后不开启shell，<code class="highlighter-rouge">-f</code>在ssh连接成功后会把ssh搁到后台。</p>

<hr />

<h3 id="section">实际场景</h3>
<p>复习完基础知识，就到实际场景应用了，既然是受限环境，那各式各样政策规定和陈腐的基础设施，就会导致各种奇葩的问题需要解决。事实上，我们这些软件从业者工作在一个纯软件堆砌的工作平台上，可以说软件，或者说技术，理论上可以解决一切问题，前提是成本的考量和政策规范的允许。当软件因故做不到一些事情的时候，政策规定和游戏规则可以来弥补；当博弈成本太高不堪重负的时候，软件可以来帮忙。这儿其实在做第3类事情：技术救场，算是局部优化，虽然有效，终究不是正途。</p>

<p>场景是这样的，有这样1台服务器，我们称它为workstation，它分别可以ssh到另外2台服务器上去，我们分别称为A和B。workstation可以分别和A、B ssh连接，但是反之则不行，而A和B之间是网络隔离的，现在我们需要让A可以从B获取数据，比如B上面开启一个HTTP Server，让A能够访问。哦，对了， workstation还是一台Windows Server，呵呵。</p>

<p>首先需要在Windows上能够进行ssh操作，并且可以打开端口转发，精品小工具Putty就可以完成这个操作，只不过它的<a href="https://howto.ccs.neu.edu/howto/windows/ssh-port-tunneling-with-putty/">tunnels设置</a>不如命令行明快，如果内心深处对命令行/Linux有追求，可以安装Cygwin，Git Bash等工具。</p>

<p>有了前面Local Port Forwarding和Remote Port Forwarding的知识准备，串联起来就可以达到效果，假定serverB上面开启了一个4000端口的HTTP Server，分别启用下面两个端口转发：</p>

<ul>
  <li><code class="highlighter-rouge">[alice@workstation ~] $ ssh -R 2000:localhost:3000 alice@serverA</code></li>
  <li><code class="highlighter-rouge">[alice@workstation ~] $ ssh -L 3000:localhost:4000 alice@serverB</code></li>
</ul>

<p>那么在serverA上访问本地端口2000，就可以访问到serverB的4000。</p>

<p>这个场景可以再扩展一点点，假定serverA所在的机房有个集群，除了serverA还有serverA1、serverA2、serverA3 ……，这些serverAn网络互通，并且都需要访问serverB上端口4000的HTTP Server，怎么办？
首先，针对ssh的远端端口转发，绑定在远端host上的那个端口，（比如<code class="highlighter-rouge">[alice@workstation ~] $ ssh -R 2000:localhost:3000 alice@serverA</code>中的2000），默认只接受来自localhost的请求。想要破坏掉这一点，修改<code class="highlighter-rouge">/etc/ssh/sshd_config</code>配置文件中的<code class="highlighter-rouge">GatewayPorts</code>为<code class="highlighter-rouge">yes</code>，重新加载sshd服务就可以了，这样，这些serverAn机器，统一访问serverA上的2000端口，即可以访问到serverB的4000端口。</p>

<hr />

<h3 id="refers">Refers</h3>
<ul>
  <li>https://help.ubuntu.com/community/SSH/OpenSSH/PortForwarding</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>写Ansible脚本为什么这么痛</title>
	  <link>//ansible-pitfall</link>
	  <author> </author>
	  <pubDate>2016-04-01T20:34:56+08:00</pubDate>
	  <guid>//ansible-pitfall</guid>
	  <description><![CDATA[
	     <p>在最近的这个项目上，我们选择了用Ansible做基础环境的搭建和软件包的部署。Ansible，相对于Puppet和Chef，要更简洁和干净一些，首先是agentless，被控机器上不需要安装任何依赖；其次YAML格式的状态声明语句和playbook，比Ruby的DSL要更简洁一些。但是跟很多新技术一样，小规模玩一玩觉得还蛮有意思，上了规模之后，各种坑和痛点就显现出来了。我在这里罗列一下我们遭受的创痛，供后来人参考。注意首先我在这里只破不立，只描述痛点，不一定提供解决方案；其次我列出的坑不一定只限于Ansible，用其他的DevOps工具也可能会遇到，有些问题甚至是做运维相关工作无法避免的。</p>

<h3 id="section">没测试，反馈周期太长</h3>
<p>Ansible，Puppet，Chef这些DevOps工具，或者说Infrastructure as Code工具的目的之一，就是用code来管理/描述infrastructure。但是写这些代码跟写产品代码的体验很不一样，我们遇到最大的一个问题，就是不能及时有效的验证我们写的Ansible task是正确的。在写产品代码时，我们有从UT（单元测试）到E2E测试（端到端测试）等不同粒度的反馈机制来验证和保证我们写的代码的正确性，但是对于Ansible来说就没那么容易了，你总不能在本地用vagrant搭建一整套集群环境来验证，即使能这样，Ansible脚本执行一遍所花的时间，和你摁几个快捷键就能刷一遍UT相比，还是太低效了。</p>

<p>因为缺少得力的测试框架，在维护Ansible脚本的时候，我们倾向于要么（1）对于小的改动，直接在Ansible工程中的修改，不加验证，提交之后直接走CI（持续集成）看结果；要么（2）对于大的改动，在现存的某个集群环境上，边运行、看结果，边修改。对于（1），很明显，天知道你这次的修改是不是对的，对于Ansible熟手——真的熟手，并且对现存的infrastructure有充分了解的熟手，这么干的可操作性还尚存一些；对于看着自己修改的diff就自信心爆棚的熟手，那多半是把CI搞挂，再反复个若干次。对于（2），因为重新搭建一套专门用于测试Ansible的环境成本太高，特别是当infrastructure比较复杂，集群的组建有数十个的时候就更困难了，于是大家倾向于在现存的UAT（用户验收测试环境）或者E2E环境上调试，但这会导致一个比较隐蔽的问题——Ansible的执行是依赖于机器的初始状态的，你在现存环境上的每一次运行和调试都可能已经修改的机器的初始状态，所以尽管最后你的修改跑通了，其正确性也是个问号，如果不正确，那么下次CI上的build（构建任务）在provision（这个不知道怎么翻译）的环节挂掉的时候，你又得回过头来重新审视。</p>

<h3 id="section-1">机器的初始状态，和幂等性的保证</h3>
<p>Ansible等这些工具带来的理念除了Infrastructure as Code之外，还有一个是DSC（Desired State Configuration），即<u>对你想要的状态进行声明</u>式环境配置。比如你要安装apache这个包，那么你在脚本里声明一下我想要httpd这个包，它的状态是present的就行了，Ansible检查已经存在就不做动作，如果没有则安装，这一点上和shell脚本拉开了距离。但是在一个诺大的Ansible工程里，很难保证所有的task都是按照状态声明的理念来写的，这就和shell脚本又回到了同一起跑线上——即脚本执行的成功与否，依赖于机器的初始状态，而初始状态是很难保证的。前面说了，在现存环境上调试还未写就的脚本就会导致机器初始状态不一致；对于同样的CentOS 6.5 64bit，在不同的客户那里，由于网络、机器硬件等原因都会导致初始状态不一致。所以我们在用Ansible等工具对infrastructure做了管理之后，幻想着一次编写到处执行，就又变成了一次编写到处调试，花费比预期多的多的时间。</p>

<p>怎么能快速有效的保证机器的初始状态呢？结合虚拟化技术，锁定镜像，这样机器重建过之后，就可以保证机器的初始状态是绝对一致的，这次工作的Ansible脚本下一次也是绝对可以工作的。如果不能做这样的保证，那么在写Ansible脚本的时候就要考虑很多额外因素，比如幂等性，你最起码要能保证即使是用流程化方式撰写task，一次成功运行之后再次运行n次也能成功。还有migration（迁移），当你需要对infrastructure做调整的时候，你需要考虑调整之后的Ansible脚本和现存环境的当下状态是否冲突，如果冲突，则需要运行一下ad-hoc的Ansible命令做一次migration，或者做脚本调整的时候就把migration考虑进去。</p>

<h3 id="ansible">Ansible的坑</h3>
<p>Ansible虽然简洁和干净，但是也有不少bug或不合理的地方。</p>

<p>首先是抽象不足，既然目标是DSC，那么我对目标状态的声明越远离机器细节越理想，但是对于安装最基本软件包这样最基本的task，rpm系和deb系软件包名不一样这样的差异也反映到了Ansible脚本的层面，比如<code class="highlighter-rouge">apache2</code>和<code class="highlighter-rouge">httpd</code>。当然你可以用<code class="highlighter-rouge">ansible_os_family</code>做判断，但是既然Ansible知道当前OS的family，那我自然也期待她能把软件包名抽象掉。</p>

<p>Ansible对于机器建模，有group的概念，比如对于<code class="highlighter-rouge">app_servers</code>这个group，它包含了<code class="highlighter-rouge">node01</code>，<code class="highlighter-rouge">node02</code>，<code class="highlighter-rouge">tomcat01</code>，<code class="highlighter-rouge">tomcat02</code>，对于一个完整的集群环境，<code class="highlighter-rouge">node01</code>/<code class="highlighter-rouge">02</code>，和<code class="highlighter-rouge">tomcat01</code>/<code class="highlighter-rouge">02</code>是4台不同的机器。但是当机器紧张的时候，我们可能会吧<code class="highlighter-rouge">node01</code>和<code class="highlighter-rouge">tomcat01</code>部署到同一台机器上，<code class="highlighter-rouge">node02</code>和<code class="highlighter-rouge">tomcat02</code>部署到同一台机器上，4台机器的声明，实际只有2台机器。而Ansible有并行部署的功能，当我们对<code class="highlighter-rouge">app_servers</code>这个group执行某个task的时候，Ansible会同时连接到4台声明的机器上（虽然实际只有2台），并行的执行任务。在同一台机器有两个进程同时执行同样的任务，就很有可能会冲突，导致失败。</p>

<p>还有很多很细碎的坑，比如Ansible的group可以继承，如果group A继承group B，那么A和B同名的group variable就会冲突。还有对于特定版本的CentOS，Ansible走ssh连接机器会出现不稳定的情况，得切换到paramiko等等等等。</p>

<h3 id="section-2">总结</h3>

<p>即使是用Ansible如此充满了业界先进理念的工具来帮助管理infrastructure，面临的问题域还是一样的，就是充满细节，琐碎，不稳定的底层机器和环境，更换一台机器，很多细节都不能保证。用工具能帮我们省一些力气，但是复杂性一上来，该费力的地方还是会费劲。</p>

<p>虽然我们被Ansible搞的很痛，但这仍是一个正确的方向，因为我们在Ansible实践上发现越多的问题，就越说明我们的infrastructure越复杂，既然已经复杂到这个程度了，总归得用个什么工具给管理起来，要么old fashioned way的用shell脚本，要么就用工具，用工具显然是优于赤裸裸的写脚本的。说到底，做infrastructure相关工作的体验没有写代码舒服，还是因为这门技术跟后端相比，发展的还不够，伴随着它成为瓶颈，很多工具和实践也会<s>慢慢</s>演化出来，容器技术就已经从另外一个方向上开了一个好头了。</p>


	  ]]></description>
	</item>

	<item>
	  <title>年轻不再，气也不盛了</title>
	  <link>//youth-review</link>
	  <author> </author>
	  <pubDate>2016-03-14T01:34:56+08:00</pubDate>
	  <guid>//youth-review</guid>
	  <description><![CDATA[
	     <p>在一个闲适的周日下午，看了这部平静、丰富、有趣的电影<em>Youth</em>，败了一笔的中文翻译作《年轻气盛》，一点毛关系都对不上。</p>

<p>首先，这是一部关于老去的电影，和Benjamin Button生长的老人院不一样；<em>Youth</em>的故事定格在一所度假村，度假村里有老人也有年轻人，还有大泳池，电影从头到位不遗余力的展示老去的肉体、肥胖的肉体、年轻的充满诱惑的肉体，和肉体之间的碰撞和摩擦。</p>

<p>迈克尔凯恩身边的那个影星Jimmy演的很好，我翻了翻豆瓣，原来就是阳光小美女里不说话的哥哥，囚徒里的精神病——Paul Dano，我每次都认不出他来。Paul饰演的Jimmy很有韵味。作为一个影星，气场上和凯恩饰演的Fred这样一个固执的老派音乐家感觉距离很大，但是同时又轻快稳重收敛，让Fred愿意接纳他。他俩的第一场对话虽然话题岔开了，但是他表现出来的魅力吸引住了Fred和我。</p>

<p>Jimmy为他职业生涯里的Mr. Q深深的困扰，就像基顿饰演的Riggan看到鸟人的海报就生起无名火；尽管在这部电影里导演安排了一个小女孩宽慰了Jimmy和我们观众，鸟人里Riggan排的舞台剧最后也大获成功，但是大众的脸谱化记忆实际上是躲不掉的，大众的喜好和自己的喜好终归是有偏差，一个成功的艺术家，既会伺候好群众和市场，也会伺候好自己和艺术，不必为此多烦恼。</p>

<p>电影中的瑞典风景真是美极了，Fred和Mick在田野里散步聊老去和回忆往事的情节，让我想起<em>Mr. Holmes</em>里已故Ian饰演的老福尔摩斯，同样是美丽的田园风光，但那个老去的故事更加刻骨铭心一些。这部电影围绕着Fred这个老头子展开了很多条线的故事：Jimmy琢磨新角色，Fred女儿的感情波折，Mick的创作，马拉多纳减肥等等，内容很丰富，导演实际上是给度假酒店画群像，导演个人风格很强烈，美学功力也高，画出来的就好看。</p>

<p>不知道Fred为什么最后又同意去给女王指挥<em>Simple Songs</em>了，毕竟，在这部讲述老去的电影里，跟马拉多纳和Mick不同，他是唯一没有被时代抛弃的人。</p>


	  ]]></description>
	</item>

	<item>
	  <title>边境杀手 Sicario 影评</title>
	  <link>//sicario-review</link>
	  <author> </author>
	  <pubDate>2015-12-17T20:34:56+08:00</pubDate>
	  <guid>//sicario-review</guid>
	  <description><![CDATA[
	     <p>Sicario 《边境杀手》是今年看过最亮眼的一部电影，风格犀利，年度最佳。</p>

<p>电影的基调很冷、很压抑，从摄影到节奏都是这个气氛。一开始不明就理的叙事，故意让观众体会女主的困惑。在这种调调下面，依次安排进暴力元素：爆炸、虐囚、特种部队行动、枪战、复仇等等，开始的节奏比较快，到后来就变的舒张、慢性。摄影尤其讲究、画面极美。并且，别具一格的是，这些暴力，出于剧情里的政治目的，全都由女主角陪同，以观察者的身份，从她的视角，一一展开，在充满雄性激素的火药味里中融入了女性荷尔蒙。</p>

<p>女权主义者可能会很失望，女主在这部电影里并不是巾帼英雄范儿，而是一个被碾压、牺牲者角色。电影里不断穿插着女主惶恐困惑的眼神，焦虑、疲惫的体态，乃至最后被枪指着下巴流泪，这些都让人看着很不忍，导演用如此种种撩拨着观众的神经，打开了这部电影真正的主角——<b>暴力</b>的另外一个视角。</p>

<p><br />
上一次看到女主Emily的表演是在《明日边缘》里给阿汤哥配绿叶，这次的角色和那部电影里的角色有一点相似，但是这一次的Kate比上一次的Full Metal Bitch要复杂和立体的多。Kate是一个坚强的FBI女探员，一开始在尸臭味熏天的屠杀现场表现的仍然足够镇定。但是她年轻、没有政治经验，在玻璃会议室里被一帮老男人盘问的时候即表现出了六神无主和一丝无助，Emily拿捏的特别好。这帮无耻的老男人成功激发出了Kate内心的正能量，让她加入到了特别行动小组，自此便是她噩梦的开始。一开始执行任务不知所措的眼神，渐渐的开始焦虑、疲惫，最后奔溃，Emily一步一步表演的特别好。Kate虽然坚强，但是并没有心机，在政治面前无力招架。枪炮火药是有形的暴力，政治是摧残人心的无形的暴力。</p>

<p>男一和男二在电影里对自己角色的表演都很到位，毫无PS痕迹，但是毕竟角色简单，远不如Emily丰富。布洛林演一个痞子，虽然戏份不多，但痞气十足。本托罗，静若处子、动若脱兔，一开始觉得他静的部分太闷了，等看到后来了解了剧情，再返回去看的时候，他的闷，其实是表现一个家人惨遭毒手的男人内心的痛苦、麻木和疲惫，其实蛮到位的。</p>

<p><br />
这部电影的第二场动作戏（押送犯人那场）非常精彩。这场戏前后有15分钟左右，但是枪战的部分不超过1分钟，前面10分钟一直在铺垫，一直渲染气氛。剧情既然安排费这么大劲押送这么重要的犯人，那肯定是要被伏击的，但是到底什么时候伏击？导演用配角讲故事、低沉急促的音乐、夸张的车队、警笛等等不断挑动观众的神经，但迟迟不开打，直到车队返回入关被堵在路上了，背景音乐停了，终于松了一口气了，此时观众大概也明白了，正戏终于要开始了。</p>

<p>根据我多年看港片街头巷战的经验，此时路上这么多车，应该是正邪双方依托这些私家车为掩护来一场枪战，子弹血肉横飞，无辜路人中弹，押送犯人的布洛林抱着嫌犯的头鼠窜。。最后要么犯人被打死，要么被解救，剩下的都成了炮灰。。。</p>

<p>但是并没有，他们先spot到打算伏击他们的车，然后等待行动，确认行动后快刀出鞘，出鞘斩杀之后即归鞘，丝毫不拖泥带水，前面14分钟的铺垫的都是前戏，最后1分钟直接高潮，精彩的很！</p>

<p><br />
这部电影制作的很精美，但是故事弱。支撑整个故事框架的阴谋论既没有新意，也没有elaborate，也没有铺垫，站不住脚。</p>

<p><br /></p>


	  ]]></description>
	</item>

	<item>
	  <title>Spring Data JPA 技术分析</title>
	  <link>//spring-data-jpa-internals</link>
	  <author> </author>
	  <pubDate>2015-12-07T20:34:56+08:00</pubDate>
	  <guid>//spring-data-jpa-internals</guid>
	  <description><![CDATA[
	     <p>在另一篇介绍Spring的文章<sup>[<a href="/spring-introduction">1</a>]</sup>里我介绍了Spring Data JPA，借助Spring Data JPA，对数据库做CRUD需要简单的四步操作：先创建数据库表和Java entity类；声明一个接口<code class="highlighter-rouge">ItemRepository</code>继承<code class="highlighter-rouge">CrudRepository</code>；再在接口<code class="highlighter-rouge">ItemRepository</code>里声明Query Method<code class="highlighter-rouge">findByName</code>；最后把<code class="highlighter-rouge">ItemRepository</code>注入到我们需要用到的地方，调用就可以了。</p>

<p>这篇文章再深入一点，解释/分析一下Spring在背后做了什么；为什么作为一个Spring用户，我们声明一个接口，在接口里声明一个方法，我们就可以调用这个方法了操作数据库了？</p>

<p>先从Spring AOP说起。</p>

<h3 id="spring-aop-proxy">Spring AOP Proxy</h3>

<p>AOP（面向切面编程，Aspect-Oriented Programming），是Java里常用的一个编程范式。OOP对逻辑和数据做了一定程度的封装，但是当应用运行起来之后，从数据流的角度来看，数据是从一个类实例流到另一个实例，是链式的，我们编写的业务逻辑也是在一条条调用链上做文章。而AOP则是从另一个维度做文章：比如说原来的模块划分，或者调用链是纵向的，那么AOP是从横向切入，把纵向维度中共性的部分，比如logging、auth、cache，抽取出来，并且用IoC<sup>[<a href="https://en.wikipedia.org/wiki/Inversion_of_control">2</a>]</sup>的思想，由抽取出来的<code class="highlighter-rouge">aspect</code>承担匹配和执行的责任，原来的业务逻辑不需要添加/改动任何代码。</p>

<p>举例来说，AOP可以做这样的事情：“让一个Web应用中所有Controller的POST方法执行之前打一条log”。抽取出来做这件事情的模块称为<code class="highlighter-rouge">aspect</code>，描述匹配到“所有Controller的POST方法”的谓词称为<code class="highlighter-rouge">pointcut</code>，“打log”这样的行为称为<code class="highlighter-rouge">advice</code>。</p>

<p>AspectJ是这个Java里AOP鼻祖老爷，Spring AOP兼容了一部分AspectJ的annotation，但核心还是Spring自己的，这个核心就是AOP proxy。比如我们有一个接口<code class="highlighter-rouge">Pojo</code>和它的实现<code class="highlighter-rouge">SimplePojo</code>，当没有proxy的时候，调用<code class="highlighter-rouge">SimplePojo</code>的<code class="highlighter-rouge">foo</code>方法是这样的：</p>

<p><img src="/assets/images/aop-proxy-plain-pojo-call.png" alt="Plain POJO call without Proxy" /></p>

<p>当我们创建一个<code class="highlighter-rouge">SimplePojo</code>的proxy之后，调用这个proxy的<code class="highlighter-rouge">foo</code>方法的是这样的：</p>

<p><img src="/assets/images/aop-proxy-call.png" alt="AOPproxy" />
（两张图片都来自Spring官方文档）</p>

<p>即proxy“代理”了对原对象原方法的调用，在这个代理的过程中我们可以执行<code class="highlighter-rouge">advice</code>，比如Spring AOP中的方法拦截器。下面的代码演示了如何用Spring AOP的底层API创建一个proxy。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">I</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">m</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"m in C"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="kd">extends</span> <span class="n">I</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">m</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">m2</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">proxyDemo</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ProxyFactory</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyFactory</span><span class="o">();</span>

        <span class="n">result</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="n">result</span><span class="o">.</span><span class="na">setInterfaces</span><span class="o">(</span><span class="n">I2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAdvice</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"m2"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"m2 in proxy"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">().</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">invoke</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">I2</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">I2</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m</span><span class="o">());</span>   <span class="c1">//Output: `m in C'</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m2</span><span class="o">());</span>  <span class="c1">//Output: `m2 in proxy'</span>
    <span class="o">}</span></code></pre></figure>

<p>首先声明一个接口<code class="highlighter-rouge">I</code>；类<code class="highlighter-rouge">C</code>实现接口<code class="highlighter-rouge">I</code>的同时自己定义了一个方法<code class="highlighter-rouge">m()</code>；接口<code class="highlighter-rouge">I2</code>继承<code class="highlighter-rouge">I</code>并声明了方法<code class="highlighter-rouge">m()</code>和方法<code class="highlighter-rouge">m2()</code>。ProxyFactory是Spring AOP的proxy工厂类，实例化之后，设置proxy的target为<code class="highlighter-rouge">C</code>的实例，要代理的接口为<code class="highlighter-rouge">I2</code>，然后添加一个方法拦截器。</p>

<p>方法拦截器是一个接口，我们实例化的匿名内部类的<code class="highlighter-rouge">invoke()</code>方法就是这个拦截器的回调。当调用的方法名字是<code class="highlighter-rouge">m2</code>的时候，拦截器直接返回一个字符串<code class="highlighter-rouge">m2 in proxy</code>。当调用的方法名字是<code class="highlighter-rouge">m</code>的时候，通过反射获取到target（<code class="highlighter-rouge">C</code>的实例）的<code class="highlighter-rouge">m()</code>方法，调用执行。
<br />
介绍了Spring AOP Proxy之后，就可以解释一开始那个问题的前半部分了——为什么在我们只声明了一个接口和方法的情况下，这个方法可以被调用到？事实上上面的demo已经基本上了回答了这个问题，接下来我把各部分逻辑对应到Spring Data JPA上。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Spring在创建的名为<code class="highlighter-rouge">itemRepository</code>的bean，就是一个proxy，这个proxy在<code class="highlighter-rouge">RepositoryFactorySupport</code>里完成了初始化和配置<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177">3</a>]</sup>；Proxy的target是<code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java">4</a>]</sup>，它用<code class="highlighter-rouge">EntityManager</code>实现了<code class="highlighter-rouge">CrudRepository</code>里的基本CRUD方法；Proxy的代理接口即<code class="highlighter-rouge">ItemRepository</code>和<code class="highlighter-rouge">Repository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190">5</a>]</sup>；Proxy添加了多个方法拦截器，处理自定义Query Method的拦截器是<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375">6</a>]</sup>，这个拦截器在构造函数里遍历<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象放到一个map中<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>。</p>

<p>当我们的代码调用到<code class="highlighter-rouge">itemRepository.findByName()</code>的时候，即进入到方法拦截器的<code class="highlighter-rouge">invoke</code>方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438">8</a>]</sup>，拦截器首先判断是不是Query Method<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">9</a>]</sup>，如果是的话就取出<code class="highlighter-rouge">RepositoryQuery</code>对象带参数执行，不是的话调用<code class="highlighter-rouge">SimpleJpaRepository</code>里的方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467">10</a>]</sup>。</p>

<h3 id="mini-parser">Mini Parser</h3>

<p>下面接着继续分析开题问题的第二部分，为什么我们只声明一个<code class="highlighter-rouge">findByName</code>的方法，Spring就知道如何去查询数据库了？</p>

<p>事实上细细想来这个并不特别神奇，我们在声明query methods的时候，是需要遵循规范的<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">11</a>]</sup>，既然我们定义方法遵循了规范，Spring基于同样的规范，用一个parser解析这个方法名，就能生成JPA的查询对象。</p>

<p>我们在前面提到Spring会根据<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>，这个对象就是一个迷你的parser解析query method方法名的结果，解析的入口在<sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95">12</a>]</sup>。</p>

<p>这个mini parser是自顶向下解析的，最顶上的节点类是<code class="highlighter-rouge">PartTree</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76">13</a>]</sup>，它包含两个字段/子节点，<code class="highlighter-rouge">subject</code>和<code class="highlighter-rouge">predicate</code>。<code class="highlighter-rouge">subject</code>表示要查询的结果，<code class="highlighter-rouge">predicate</code>表示查询的条件。比如对于<code class="highlighter-rouge">findByName</code>，<code class="highlighter-rouge">subject</code>为空，<code class="highlighter-rouge">predicate</code>为<code class="highlighter-rouge">Name</code>；再比如稍微复杂一点的<code class="highlighter-rouge">findDistinctUserByNameOrderByAge</code>，subject是<code class="highlighter-rouge">DistinctUser</code>，predicate是<code class="highlighter-rouge">NameOrderByAge</code>。</p>

<p><code class="highlighter-rouge">Subject</code>有3个boolean属性，分别是<code class="highlighter-rouge">distinct</code>，<code class="highlighter-rouge">count</code>，<code class="highlighter-rouge">delete</code>，<code class="highlighter-rouge">maxResults</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275">14</a>]</sup>，如果query带了<code class="highlighter-rouge">Distinct</code><code class="highlighter-rouge">distinct</code>就是true，count方法<code class="highlighter-rouge">count</code>为true，delete方法<code class="highlighter-rouge">delete</code>为true。<code class="highlighter-rouge">maxResults</code>是limit查询的值，如<code class="highlighter-rouge">findFirst10ByLastname</code>。</p>

<p><code class="highlighter-rouge">Predicate</code>有一个ArrayList<code class="highlighter-rouge">nodes</code>包含以<code class="highlighter-rouge">Or</code>split后的节点<code class="highlighter-rouge">OrPart</code>，还有一个<code class="highlighter-rouge">orderBySource</code>包含用<code class="highlighter-rouge">OrderBy</code>split的排序节点<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345">15</a>]</sup>。</p>

<p>……</p>

<p><code class="highlighter-rouge">OrPart</code>节点往后不再赘述推导规则了，最后，定义一个比较复杂的方法看一下AST。对于<code class="highlighter-rouge">findDistinctByStateAndCountryLikeOrMapAllIgnoringCaseOrderByNameDesc</code>，AST如下图</p>

<p><img src="/assets/images/ast-of-a-long-query-method.png" alt="AST of a long Query Method" /></p>

<p>有了AST之后，Spring Data再调用JPA的接口创建<code class="highlighter-rouge">Predicate</code>对象、<code class="highlighter-rouge">CriteriaQuery</code>对象等，交给JPA查询DB<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98">16</a>]</sup>。</p>

<p>这个规则和parser都很简陋，很容易出现二义的情况，如果遇到这样的情况，就不一定非要苦苦纠结于解析规则了，它目的毕竟还是为了给用户提供方便，如果不能很方便的提供方便，那就给字段改个名儿，或者改用Named Query<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries">17</a>]</sup>。</p>

<p><br /><br /></p>

<p>参考资料：</p>

<ul>
  <li>http://docs.spring.io/spring-data/jpa/docs/current/reference/html/</li>
  <li>http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html</li>
  <li>[1]http://post.lxd.me/2015-12-01-spring-introduction/</li>
  <li>[2]（控制反转的思想，不特指Spring DI） https://en.wikipedia.org/wiki/Inversion_of_control</li>
  <li>[3]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177</li>
  <li>[4]https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java</li>
  <li>[5]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190</li>
  <li>[6]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375</li>
  <li>[7]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[8]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438</li>
  <li>[9]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[10]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467</li>
  <li>[11]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[12]https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95</li>
  <li>[13]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76</li>
  <li>[14]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275</li>
  <li>[15]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345</li>
  <li>[17]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries</li>
  <li>[16]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Spring 介绍</title>
	  <link>//spring-introduction</link>
	  <author> </author>
	  <pubDate>2015-12-01T20:34:56+08:00</pubDate>
	  <guid>//spring-introduction</guid>
	  <description><![CDATA[
	     <p>这篇文章对Spring Framework做一个基础的介绍，先介绍Spring和Spring相关的几个概念，再介绍3个常用的Spring项目/模块：Spring MVC、Spring Data JPA、和Spring Boot。</p>

<h3 id="spring--java-ee">Spring 和 Java EE</h3>

<p><img src="/assets/images/spring-java-ee.png" alt="Spring and Java EE" /></p>

<p>Java平台有多个“版本”，和Spring相关的有两个：Java SE和Java EE。Java SE（Java Platform, Standard Edition）包含JVM和Java最核心/基本的类库API；而Java EE（Java Platform, Enterprise Edition）是在Java SE之上，定义的一套specifications，用来支持所谓的Enterprise/企业级开发，比如用来接受处理HTTP请求的servlet specification、和关系型数据库交互的API（JPA）等。Java EE定义的每一条规范称为JSR（Java Specification Request），由JCP（Java Community Process）开发维护，就像RFC之于IETF。</p>

<p>有标准就有实现，基于Java EE的标准，业界有好些个实现，这些实现基本都是“大公司”的产品，比如IBM的WebSphere Application Server（WAS），Oracle的WebLogic，RedHat的JBoss/WildFly等等，这些实现都遵循Java EE的标准，而且实现了Servlet spec、JPA spec等大部分重要的specification，称为应用服务器（Application Server），Java EE规范保证了我们编写的应用能够部署/运行在上面；而在开源界更常用的Tomcat/Jetty则称为Web容器（Web Container），只实现了Java EE里的Servlet spec、JSP spec等和Web相关的specification，我们如果需要依赖注入，就需要自己引入Spring，需要用JPA访问关系型数据库，就需要自己引入Hibernate。</p>

<p>而且Spring在严格意义上来说并不是Java EE的实现，因为它一方面遵循了Java EE的Servlet、JPA等核心接口，但是对于更上层的API，Spring用的是自己的东西，比如依赖注入（Spring DI vs CDI），RESTful Web Service（Spring MVC vs JAX-RS）。</p>

<h3 id="spring-ioc--di">Spring IoC / DI</h3>

<p>Spring框架最核心的概念就是它基于控制反转技术（Inversion of Control - IoC）的依赖注入（Dependency Injection - DI），这两个狰狞的名词到底是什么意思？我简单描述一下。</p>

<p>抛开Spring，IoC是一种思想，一种技术，即对于一个主体而言，原来由他主动负责/发起的工作，变成了由它被动接受，这个由主动变被动的过程，称为IoC。比如library和framework就是一个很典型的好例子：当我们使用library，我们编写的代码调用lib，我们是主动方、发起方；而当我们改用framework，我们编写的代码则作为framework的回调、实现、或被托管对象，我们从主动方变成了被动方。通过IoC，我们可以解耦，可以解除主体的责任，可以解放自己。</p>

<p>Spring IoC（a.k.a. Spring DI）就是IoC在Spring里的一个应用，它把本来应该由我们自己写代码主动负责的对象实例化和依赖引用的过程，交由Spring来完成，举个例子：</p>

<p>在不借助DI，我们用Java写一个application的时候，如果Class A依赖于Class B和Class C，我们可以把B的实例由构造函数/setter函数传进去，C的实例由A自己实例化一个出来，就像这样：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="o">();</span>

    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setB</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span><span class="o">());</span></code></pre></figure>

<p>借助Spring DI和其他一些技术，可以这样：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>这里步子跨的有点大，<code class="highlighter-rouge">@Component</code>标签告诉Spring这个类需要被实例化为一个bean，bean是由Spring管理的一个Java对象实例，所以在这里Class A B C都会被Spring实例化为bean。<code class="highlighter-rouge">@Autowired</code>标签告诉Spring去寻找一个类型匹配的bean注入到该字段/方法，形成对B和C的引用，这便是<u>依赖注入</u>。</p>

<p>所以，本来应该由的代码负责的，把B和C的实例交给A的实例引用的过程，变成了在代码中只声明依赖，由Spring完成实例化和实例之间的引用，这就是IoC — Inversion of Control——<u>控制反转</u>。</p>

<h3 id="web-container">Web Container</h3>

<p>Web Container，Web容器，也叫Servlet容器。我们用Spring构建的Web应用是要借助一个容器来运行的，比如Tomcat、Jetty，GlassFish。因为无论是用Spring还是其他Java EE框架编写出来的Web应用，都是是一个个独立的servlet，或者基于servlet的东西，这些独立的servlet不能直接运行，也不能直接接收来自浏览器的HTTP请求。Tomcat/Jetty这些容器一方面是一个Web服务器——即和浏览器交互，接收/响应HTTP请求；另一方面是Servlet容器——加载servlet，负责管理他们的生命周期，根据mapping规则把分发给响应的servlet，如下图</p>

<p><img src="/assets/images/servlet-container.png" alt="Servlet" /></p>

<p>这一整套都是Java EE Servlet规范，Spring和容器都得遵守这些规范，用Spring写的Web应用才可以部署到Web容器里去。</p>

<h3 id="spring-mvc">Spring MVC</h3>

<p>Spring框架由诸多模块组成，最核心的有spring-core、spring-beans，和数据库交互的有spring-jdbc、spring-orm等，我们用Spring来构建Web项目比较多，所以介绍一下Spring Web MVC模块。</p>

<p>Servlet是Java EE里处理HTTP请求的技术/规范，Spring MVC也是基于servlet来设计的，基于一个核心的<code class="highlighter-rouge">DispatcherServlet</code>，HTTP请求进来之后由它分发给其他的Controller处理。下面是在Spring里写一个Controller的demo，另外Spring MVC提供了Model-View-Controller的完整功能，但在这前后端分离的年代，就只demo提供RESTful API、返回JSON的Controller写法：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/stores/{storeId}/items"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemController</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/{itemId}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="n">produces</span> <span class="o">=</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_UTF8_VALUE</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Item</span> <span class="n">retrieveItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">storeId</span><span class="o">,</span> <span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">itemId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">ResponseEntity</span> <span class="n">createItem</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">@RestController</code>标记在一个Java类上，告诉Spring MVC这是一个RESTful API Controller，所有的Controller同时也都是Spring管理的bean；</li>
  <li><code class="highlighter-rouge">@RequestMapping</code>描述了URL的路由映射。标记在类上的<code class="highlighter-rouge">@RequestMapping</code>定义了顶层的路径，结合在方法上的<code class="highlighter-rouge">@RequestMapping</code>的路径和HTTP method，将一个HTTP请求映射到一个Java方法上，由这个方法来处理HTTP请求，返回HTTP响应。</li>
  <li><code class="highlighter-rouge">@RequestMapping</code>中定义路径的字符串支持URI Template<sup>[<a href="https://tools.ietf.org/html/rfc6570">1</a>]</sup>，路径中{变量}所代表的的值，用<code class="highlighter-rouge">@PathVariable</code>标记在同名的Java方法参数上提取出来。</li>
  <li><code class="highlighter-rouge">@RequestBody</code>标记在Java方法参数上，Spring MVC会自动把HTTP请求转成Java对象，绑定在这个参数上；同样的，因为我们标记了这个类为RESTful Controller，Java方法的返回值会直接转成JSON；</li>
  <li><code class="highlighter-rouge">ResponseEntity</code>是一个泛型类，包装了Controller返回的HTTP response内容，增加了可以控制HTTP响应头、状态码的方法，代码里返回一个空的HTTP响应，状态码设置为200。</li>
</ul>

<p>写一个最简单的Item类，用cURL调用RESTful接口可以看到下面的执行结果：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ curl -v http://localhost:8080/stores/16/items/1
...
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Type: application/json;charset=UTF-8
...

{"name":"hehe"}%</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">curl -v -H "Content-Type: application/json" -i -X POST -d '{"name":"haha"}' http://localhost:8080/stores/16/items
...
&gt; Content-Type: application/json
&gt; Content-Length: 15
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Length: 0
...</code></pre></figure>

<h3 id="spring-data-jpa">Spring Data JPA</h3>

<p>过去我们谈起Spring是一个framework，但是现在的Spring更多的像一个family/collection，基于核心的Spring Framework之上做了好些project<sup>[<a href="https://spring.io/projects">2</a>]</sup>，Spring Data就是其中之一。Spring Data给数据库的访问提供了一个更优雅/强大的接口，Spring Data JPA是基于JPA、针对关系型数据库的子模块，给我们写应用日常遇到的简单CRUD提供了一个非常干净的接口。</p>

<p>Spring Data / JPA 提供给我们用户的是一系列Java interface，它在背后用基于Dynamic Proxy的AOP帮我们完成了实际的工作。最顶层的<code class="highlighter-rouge">Repository&lt;T, ID extends Serializable&gt;</code>，提供了最基本CRUD操作的<code class="highlighter-rouge">CrudRepository&lt;T, ID extends Serializable&gt;</code>，JPA相关操作的<code class="highlighter-rouge">JpaRepository&lt;T, ID extends Serializable&gt;</code>等。它们都是泛型接口，第一个类型参数是对应到数据库的实体类，第二个参数是实体类里ID的类型。我们声明一个接口继承这些接口，再申明一些我们自己的方法进去，就可以完成大部分简单的数据库操作了。</p>

<p>借助Spring Data JPA，对数据库做简单的CRUD需要四步操作：</p>

<p>第一步，在数据库中创建表，然后创建一个entity类映射它</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">item</span> <span class="p">(</span>
  <span class="n">id</span>          <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">name</span>        <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">description</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">itemPk</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">generator</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">)</span>
    <span class="nd">@GenericGenerator</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">,</span> <span class="n">strategy</span> <span class="o">=</span> <span class="s">"uuid2"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">description</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">description</span> <span class="o">=</span> <span class="n">description</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">description</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>第二步，声明一个接口，继承填入类型参数的<code class="highlighter-rouge">CrudRepository</code>接口</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<p>第三步，<code class="highlighter-rouge">CrudRepository</code>接口里已经声明了一些最基本的CRUD方法<code class="highlighter-rouge">save(S entity)</code>，<code class="highlighter-rouge">findOne(ID id)</code>，<code class="highlighter-rouge">exists(ID id)</code>，<code class="highlighter-rouge">delete(ID id)</code>等，我们可以在声明的接口里再进一步声明一些我们业务上需要的方法，但是要根据一定的命名规则<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">3</a>]</sup>。比如根据<code class="highlighter-rouge">name</code>查找出所有同名的item的方法声明为<code class="highlighter-rouge">findByName</code>。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>第四步，把<code class="highlighter-rouge">ItemRepository</code>注入到我们需要用到的地方，调用就可以了</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClient</span> <span class="o">{</span>
  <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">ItemRepository</span> <span class="n">itemRepository</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomething</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="s">"teapot"</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomethingElse</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Item</span> <span class="n">newItem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Item</span><span class="o">(</span><span class="s">"smug"</span><span class="o">,</span> <span class="s">"smug without mug"</span><span class="o">);</span>
    <span class="n">itemRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">newItem</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>自定义查询方法除了简单的findBy…以外还可以进行更丰富的组合：and、or、pagination、limit、asc/desc等<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">3</a>]</sup>。</p>

<p>那么Spring Data是怎么做这些magic的？其实这对Spring核心来说来说都不是很困难。首先用基于Dynamic Proxy的Spring AOP，创建一个proxy作为<code class="highlighter-rouge">itemRepository</code>的bean实例，然后解析所有的自定义方法如<code class="highlighter-rouge">findByName</code>，用一个迷你的parser解析方法名，将AST保存在bean上；当应用启动我们的代码调用到<code class="highlighter-rouge">findByName</code>的时候，Spring AOP拦截了方法调用，取出AST，解析成一个Query对象，再结合参数交给JPA实现做查询，我在另外一篇文章<sup>[<a href="http://post.lxd.me/2015-12-07-spring-data-jpa-internals">4</a>]</sup>做了更详细的分析。</p>

<h3 id="spring-boot">Spring Boot</h3>

<p>Spring Boot是另一个Spring project，Convention over Configuration风的追随者。它基于Spring做了很多工作，使得编写一个Spring应用变的非常容易。</p>

<p>以往我们初始化一个Java应用需要在maven/gradle配置文件里历数写上它的依赖，非常繁复，Spring Boot非常体贴的给我们提供了<code class="highlighter-rouge">Start POMs</code>——一站式的jar包依赖解决方案。它从Spring用户的视角，对有关联的、通常会一起使用的第三方依赖做了编组，当我们需要Spring的哪部分功能的时候，在配置文件里写入对应编组的artifactId作为依赖就好了。比如我们需要做Web应用，一般需要Spring MVC的依赖，spring-web模块，Jackson的依赖等，在Spring Boot里我们引入<code class="highlighter-rouge">spring-boot-starter-web</code>就可以了。类似的还有包含JUnit、Hamcrest和Mockito等测试工具的<code class="highlighter-rouge">spring-boot-starter-test</code>，Spring Data JPA相关的<code class="highlighter-rouge">spring-boot-starter-data-jpa</code>等。</p>

<p>传统的Spring Web应用打包之后需要放在Tomcat/Jetty容器下面运行，Spring Boot应用引入<code class="highlighter-rouge">spring-boot-starter-web</code>依赖之后还会引入一个内嵌的Tomcat，这个内嵌的Tomcat可以通过调用<code class="highlighter-rouge">SpringApplication.run()</code>再借助Spring Boot的自动配置启动。这样我们编写一个入口main函数，就可以直接启动Web应用了，无论是命令行、IDE、亦或打成一个独立的jar包用<code class="highlighter-rouge">java -jar</code>运行。</p>

<p>Spring Boot在减少配置方面还做了很多细的调优。比如对于ORM，一个Java entity类对应到数据库的一张表的时候，默认Java entity类的字段名对应到数据库的字段名。如果JPA用的是Hibernate，并且配置了<code class="highlighter-rouge">ImprovedNamingStrategy</code>，就可以把entity类里的camelCase的字段名映射到数据库表里snake_case的字段名，很有Convention Over Configuration的范儿了，但是对于外键却是不生效的。Spring Boot提供了一个<code class="highlighter-rouge">SpringNamingStrategy</code>继承<code class="highlighter-rouge">ImprovedNamingStrategy</code>，添加了对外键的支持。</p>

<h3 id="section">一些细节</h3>
<blockquote>
  <p>不要在意那些细节！</p>

  <p>  <span style="float:right; margin-right:10%">—— Coney Wu</span></p>
</blockquote>

<p>Spring 自动装配（autowire）就是自动发现匹配的bean注入到有依赖的bean里面去。所谓自动发现，就是Spring扫描ApplicationContext。所谓匹配，有两种，一种是byName——有依赖的bean的属性名字和被依赖的bean名字相同；另一种是byType——有依赖的bean的属性类型和被依赖的bean类型相同，当有多个同一类型的bean的时候，就会抛exception。@Autowired annotation是byType匹配的，如果有多个同类型的bean，可以结合@Qualifier annotation<sup>[<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-autowired-annotation-qualifiers">5</a>]</sup>指定到特定的bean上。</p>

<p>如果bean之间互相依赖，或者出现环会不会报错？——如果整条环上的bean之间都是<u>构造函数依赖注入</u>的方式互相依赖的话就会报错，前面实例代码里的注入方式即<u>构造函数依赖注入</u>，这种依赖注入方式表明要想实例化class A，必须先注入class B的实例化bean，如果class B也构造函数注入依赖于class A，那么就陷入死循环了。解决方法是把Spring启动先初始化的那个bean的<u>构造函数依赖注入</u>换成基于setter函数的依赖注入，或者用<code class="highlighter-rouge">@Autowired</code>注入到类的字段。但是通常情况下我们又不想去关心/控制bean的初始化顺序，这时候全部用setter函数注入或者用<code class="highlighter-rouge">@Autowired</code>注入类字段就是比较省心的方案。</p>

<p>Web容器和Web应用交互的入口点是一个称为deployment descriptor file的文件，即web.xml，再WEB-INF/文件夹下面，它定义了诸如servlet、servlet和URL的mapping、event listeners等</p>

<p>Java对象到JSON的相互转换只是属于Java和HTTP req/res相互转换中的一种，转换方法都继承于<code class="highlighter-rouge">HttpMessageConverter&lt;T&gt;</code>接口。在Spring里注册有有多个实现类，JSON的转换是由<code class="highlighter-rouge">MappingJackson2HttpMessageConverter</code>完成的，依赖于Jackson。</p>

<p>Spring Boot的另一个消灭手动配置的重要手法是自动配置，即根据应用现在CLASSPATH里的依赖的jar自动配置Spring，用<code class="highlighter-rouge">@EnableAutoConfiguration</code>注解开启，对Spring Boot来说几乎也是必须的。</p>

<p>Spring Boot应用有一个入口类标记了<code class="highlighter-rouge">@Configuration</code>。还有一个静态的main方法作为程序的入口，main方法再调用<code class="highlighter-rouge">SpringApplication</code>，把当前类作为入口配置传参数进去，<code class="highlighter-rouge">SpringApplication</code>再去启动内嵌tomcat等后续过程。</p>

<h3 id="further-reading">Further Reading</h3>

<p>这篇文章对Spring做了一个很基本的介绍，略去了很多的细节，Spring的官方文档提供了更全面和详细的阐述<sup>[<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/">0</a>]</sup>。Spring的模块/项目/子框架很多，除了我介绍的这三个，还有如切面编程的Spring AOP，Authentication和Authorization的框架Spring Security等等都是易学好用的车轮子。Spring Boot除了我上述的几个特性以外也还有很多值得关注的内容，如Spring Initializer、用于生产环境监控的actuator等等，一切的一切，都在Spring的官方文档里。</p>

<p><br /></p>

<p>参考资料：</p>

<ul>
  <li>https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html</li>
  <li>http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html</li>
  <li>http://docs.spring.io/spring-data/jpa/docs/current/reference/html</li>
  <li>http://sivalabs.in/2015/06/a-developers-perspective-on-spring-vs-javaee.html</li>
  <li>[0]http://docs.spring.io/spring/docs/current/spring-framework-reference/html/</li>
  <li>[1]https://tools.ietf.org/html/rfc6570</li>
  <li>[2]https://spring.io/projects</li>
  <li>[3]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[4]http://post.lxd.me/2015-12-07-spring-data-jpa-internals/</li>
  <li>[5]http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-autowired-annotation-qualifiers</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>王晶的香港电影史</title>
	  <link>//Jing-Wong-autobiography-review</link>
	  <author> </author>
	  <pubDate>2015-02-17T20:34:56+08:00</pubDate>
	  <guid>//Jing-Wong-autobiography-review</guid>
	  <description><![CDATA[
	     <p><img src="https://img1.doubanio.com/img/celebrity/large/3237.jpg" alt="王晶" /></p>

<p><br />
王晶导演的电影不怎么喜欢，但是形象很可爱，胖胖的、笑眯眯的，憨态可掬。最近翻到到他写的自传：《少年王晶创江湖》（原发于明报周刊，这是单行本）。写的很好，很精彩，说了不少大实话，我拣几段抄在这里。</p>

<p>王晶先入行电视业做编剧，积累了深厚的喜剧功底，年少成名，很早就制作出了一批收视率极高的剧集，“一九七九年《网中人》达到三百万人收看。当年我二十四岁”。后来转入电影业做导演，说起为什么做导演，王晶开了个玩笑：</p>

<blockquote>
  <p>有人为了艺术理想做电影导演。
有人为了虚荣心做电影导演。
有人为了娱乐圈的五光十色做电影导演。
我是为了老婆大肚，愁分娩的费用而做导演的。。。并事先声明并非奉子成婚，这不是道德问题，是不想被人认为我性知识贫乏。。。</p>
</blockquote>

<p>在书中王晶多次提起自己经济出现问题。在九七年香港电影最不景气的时候，他为了保持制作，“把多年来在电影上赚的钱一点一滴的补贴了出去“，虽然同业并不领情。到最后他手头可以调用的资金不多，打算结束电影公司的时候，遇到了一位贵人出手相助，他在叙写之前大发了一番感慨：</p>

<blockquote>
  <p>我一生当中有好多次的奇遇，都是因为去了一些没兴趣、不重视、甚至不想去的场合发生的。我们常会把一些场合视为鸡肋，浮起一个去唔去都罷的想法。
但这是错的。你永远不知道命运把金币埋在什么地方。上天会眷顾一些尊重朋友、尊重生命、不吝啬去释放善意、释放正能量的人。</p>
</blockquote>

<p>然后他去了一个鸡肋同学会，和之前并不熟络的一位同学聊的很好，后来得到他支持十多年。</p>

<p><br />
什么是导演的原罪？楚原先生给他讲了一句金句，一下子就给商业片正了名：</p>

<blockquote>
  <p>阿晶，电影圈泡女演员不是罪，迟到早退不是罪，扮嘢擺款也不是罪；而只有一条死罪，就是 唔收得！</p>
</blockquote>

<p>港片为什么家道中落，我也觉得是太商业，烂片太多，但是王晶义正严辞的给出了他的答案：</p>

<blockquote>
  <p>好多人说港片式微是因为滥拍及急功近利。这根本是阿妈系女人式的理由，讲滥拍，美国几十年来都是最滥拍的电影王国，最 top收过几亿美金的只有三十部左右大片，其他就是近千部几百万到一千万成本的渣片，直接印 DVD、或上电影频道。那些片有的真是任何一部C级港片都好过佢，但美国电影到今天仍影响整个世界。为什么呢？<br />
因为真正的市场理论指出，好片有观众，渣片也有观众，好多片你不会买飞入场睇，但半夜无聊打开收费电视机，你就会睇。观众形式的不同，会令你有不同选择。老实说，市场好，什麼电影也能生存，市场差，好片烂片一样死，我三代电影人（叔公王鹏翼是五十年代的制片人），数据比任何电影人都多，我知这才是市场定律。</p>
</blockquote>

<p>最近在香港港人和大陆人起了不少冲突， “在内地闯天下的学问”这一章里写了不少他作为一个电影人在大陆的电影江湖里打拼的所见所感，很有意思：</p>

<blockquote>
  <p>国内人的价值观跟香港人本质上有太多的不同之处。<br />
老实讲，港人几十年来的自我优越感，视国内人为素质较低、老土、娘等观念（娘？！），大陆人何尝不知，而且相当反感。被香港人打压了几十年的国内人才，今日遇上了出头天，自我膨胀的比以前的想感人更甚，而且普遍有「你地都有今日咯」的想法，如果香港人与国内人有争拗，很大机会偏向于国内人帮国内人！香港人被围攻，被群插（群插？）的机会极大。</p>
</blockquote>

<p>台湾人我见过，看到这里我愈发觉得，无论是香港人还是台湾人还是大陆人，还真的都是中国人。</p>

<p><br />
提到《让子弹飞》，王导演更是满肚子委屈：</p>

<blockquote>
  <p>取出这几年报批片子及剧本意见一比较。老实说，我也觉得这是两套标准。如果《让子弹飞》的编剧是我，深信是会被剪的体无完肤。当然我没异议，照旧拍我的片好了。猛虎是必然不敌地头蟲的，就付出双倍的努力去追上吧！</p>
</blockquote>

<p><br />
打官司：</p>

<blockquote>
  <p>香港人打的是钱，大陆人打的是人面。<br />
当然公说公有理，婆说婆有理，谁对谁不对，外人不易了解。但作为在国内工作的香港人，我劝大家万事以和为贵，非到万不得已，不要公堂相见，同时要收敛自己的优越感，因为国内人才辈出，在哪一方面已不输香港人。反而拼搏精神远胜过我们。我们要在国内创出一片新天地，除了努力之外，广结人缘更为重要，多一个朋友点都好过一个敌人。中港一家亲，才是揾食态度。</p>
</blockquote>

<p>这已经是书的最后部分了，和前半生的锋芒毕露相比，实在是圆滑了不少，多了不少佛心，但是难能可贵的是对于他认为改坚持的东西，还是能够义无反顾的坚持。</p>

<p>王晶的父亲王天林先生也是著名导演，回忆起父亲，王晶心酸满满，因为父亲一辈子吃了太多苦，最后一章”给敬爱的父亲“情真意切。王晶小时候家境也并不好，并且——</p>

<blockquote>
  <p>这也直接令我的人生态度成形。我决定走不空谈只务实的路，我不能再让家人受我跟父亲一样的苦。所以三十年来我只拍商业片，但我敢说，我给了我家人我能提供的最好的东西。”</p>
</blockquote>

<p><br />
这本书写的很真诚，以讲故事，和人生感悟为主，对于一些敏感的人事冲突火力并不强（只提到了李翰祥导演打压他以及跟周星驰之间的一段不愉快）：</p>

<blockquote>
  <p>因为很多人仍在江湖，许多事我都采用了十分保守的笔法，尽量不要引起不必要的争议或误解。所以又好多很想直写的人与事，我都保留了。到正式退休的那一天，希望我有机会再在这里为大家写一百期的《王晶回首红尘》。相信会更赤裸”</p>
</blockquote>

<p><br />
这本书没有在大陆出版，否则肯定会被咔嚓掉不少，港币八十八，<a href="http://s.taobao.com/search?q=%E5%B0%91%E5%B9%B4%E7%8E%8B%E6%99%B6%E9%97%AF%E6%B1%9F%E6%B9%96">淘宝</a>可以买到。繁体竖排，并且夹杂大量粤语，粤语的部分比较费劲，但是值得一看！</p>

<p><br />
<img src="https://img1.doubanio.com/lpic/s6873849.jpg" alt="少年王晶闯江湖" /></p>

<p><br />
（图片来自豆瓣）</p>

	  ]]></description>
	</item>

	<item>
	  <title>星际穿越 Interstellar 影评</title>
	  <link>//interstellar-review</link>
	  <author> </author>
	  <pubDate>2014-12-19T20:34:56+08:00</pubDate>
	  <guid>//interstellar-review</guid>
	  <description><![CDATA[
	     <p>昨天终于抽出空来赶在星际穿越下线前又去看了一遍，因为电影里永恒号飞过土星，飞过卡冈图雅的画面非大银幕看不过瘾，要是电影下线之后再在大银幕上看这部电影的机会就小很多。为了不亏待自己，再落下一篇影评。</p>

<p>对太空、星际穿越、时间旅行的光影呈现是这部电影最大的看点，就像对梦境的刻画之于Inception。对同类型的的神片2001太空漫游，Interstellar的致敬之处确实不少，让我很意外，因为印象中诺兰可是很骄傲的。
另外虽然都是商业片，相比于诺兰导演之前的TDK和Inception，这部Interstellar的堆砌感更重，剥去星际穿越华丽的外衣，再抽掉Family元素，留下的东西并不多。</p>

<p>在演员方面，安妮海瑟薇在出场的时候整个电影院观众一阵骚动——女神出场了！但整部电影下来，导演并没有给她多大的发挥空间，因为串起整部电影的是父女情，风头全被马修麦康纳抢去了。而马修麦康纳也没有辜负导演的期望，将父女之情表演的淋漓尽致，坐在电视机前一把鼻涕一把泪，赚观众的感情分效果好极了。另外马修在这部电影里为了表现柔情的一面，有些场景口齿含混的很夸张，感觉有些做作。 而马特达蒙则是一个惊喜，因为预告片里没有看到他。他虽然在中间才出场，并且很快就挂掉了，但是很出彩，达蒙演反派的代入感就是强！ :)</p>

<p>诺兰是一个技术流导演，重技术轻艺术，拍的电影大气而不细腻，感情戏一直是他电影里若有若无的弱项，而这部电影里却对父女情下了重笔墨来刻画。前面花了大力气来做情感铺垫，中间马修坐在电视机前面眼泪鼻涕横流，到最后和病床上已将要作古的女儿团聚，作为电影的主线效果非常赞！</p>

<p>诺兰的技术风格重不只是电影技术优秀，他拍的电影是情节的技术感也很重，比如Inception和Interstellar都有递归的元素：Inception里从两层梦境到三层梦境到最后跌入limbo；Interstellar里Cooper时空穿越回去给自己的女儿传送信息的同时他自己也明白了更高维空间里的人类在做着同样的事情。更早期的作品记忆碎片，正反双线叙事手法，烧脑都快烧成浆糊了，那部电影应该是他玩的最happy的电影。在致命魔术里还把特斯拉请出来造了一个克隆机器，应该是向这位伟大的科学家致敬，但是让这部复古的电影却很有硬科幻的调调。</p>

<p>和前几部电影一样，这部电影的戏很足，即使是将近3个小时的长度依然塞不下来的感觉，有些部分节奏很快。</p>

<p>后来朋友圈里刷满了这部电影怎么怎么翻拍了三体的段子，但是我是直到影片最后，Cooper从离心机空间站里苏醒过来之后，才联想起三体里修在太阳系修在行型背面的太空城的。其实首先联想到的应该是马特达蒙的Elysium，但是那部电影故事太烂就没太多想。让我吃惊的是离心机的半径好小，怎么住得下那么多人，电影也一直没有给离心机空间站的全景镜头，直到后来Cooper坐在长椅上咂啤酒的时候，导演给了一个纵向的镜头，才发现离心机的轴很长。</p>

<p>说到三体那就在说说三体，三体现在在国内科幻界乃至华人世界里都威望极高，大家提起三体就直呼神作，中国科幻的扛鼎之作云云，我抵抗不住盛威，就看了一遍，但是我没觉得盛传的那么好，作者的天马行空的想象力确实厉害，也将这些想法串联成了一个完整的故事，但是文笔太差了，作为三部小说里一条很重要的爱情线，居然也是班里的内向男生恋上女神的老土套路。看完之后在回味之余总是觉得很可惜。</p>

<p><br />
这次电影的配乐依旧是由寂寞汉子的作品，诺兰最近几部电影的配乐都是和他合作的，不同于在Inception里用重金属轰鸣：
<br /></p>
<embed src="http://music.163.com/style/swf/widget.swf?sid=1426503&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all" />

<p>这次改用管风琴轰鸣了：
<br /></p>
<embed src="http://music.163.com/style/swf/widget.swf?sid=29734868&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all" />

<p>另外Interstellar里还时不时的放这一段跟宇宙、时空很应景的很有空灵感的配乐：
<br /></p>
<embed src="http://music.163.com/style/swf/widget.swf?sid=29734857&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all" />

<p>盗梦空间里我最喜欢的一段配乐是从Cobb一行人从头等舱醒来，到Cobb惴惴不安的进关，到最后以陀螺悬念结束的配乐：
<br /></p>
<embed src="http://music.163.com/style/swf/widget.swf?sid=1426503&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all" />

<p>说到盗梦空间就再说说盗梦空间，盗梦空间从构思上绝妙，但是Ariadne的选角是一个大遗憾，Elen Page在Juno里的表演非常精彩，很有本色出演的感觉（当然我不知道Elen Page在生活中是不是真的这么大大咧咧），但是在Inception里和一帮老爷们在一起，显得太单薄了。在Inception整部电影里除去Mal这个Cobb脑中的角色，就她一个女角色，所以非常重要，但是再看看她在第二层梦境酒店里OL的装束：瘦小、平胸，衣服都撑不起来，实在太单薄了。</p>

<p>没想到在拍完盗梦空间之后又拍出这样一部优秀的原创剧本电影，仅凭借这两部电影就够无数后人仰视这位牛逼的导演了，当然希望诺兰会带来更多优秀的作品。</p>

	  ]]></description>
	</item>


</channel>
</rss>
