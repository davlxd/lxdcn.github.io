<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>post.lxd.me</title>
   
   <link>https://post.lxd.me/</link>
   <description></description>
   <language>en-uk</language>
   <managingEditor>  </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Spring Data JPA Internals</title>
	  <link>//spring-data-jpa-internals-en</link>
	  <author> </author>
	  <pubDate>2017-03-22T20:34:56+08:00</pubDate>
	  <guid>//spring-data-jpa-internals-en</guid>
	  <description><![CDATA[
	     <p>In the previous post<sup>[<a href="/spring-introduction-en">1</a>]</sup>, I showed how brief it can be for Spring Data JPA to expose routine CRUD interfaces of simple database entities. This post goes a little bit further, by revealing the work Spring has done behind the scenes, and why we can interact with the database with the methods we declared in interfaces without implementing them.</p>

<p>I’m will start with Spring AOP.</p>

<h3 id="spring-aop-proxy">Spring AOP Proxy</h3>

<p>AOP (Aspect Oriented Programming) is a very common programming paradigm, it encapsulates logics and action from an another angle comparing to OOP(Object Oriented Programming). OOP encapsulates data and actions into classes, mostly correspond to domain models; but in runtime, it’s data flows from one module to another, so it’s more like a lot of chains consisting of business logics we wrote, and this is where AOP takes over. Let’s say normal method calling chains are vertical, then AOP cuts in from the horizontal angle, which encapsulates common logics like logging, auth, and cache etc into <code class="highlighter-rouge">aspect</code>s. And AOP also uses IoC<sup>[<a href="https://en.wikipedia.org/wiki/Inversion_of_control">2</a>]</sup> to make sure original code and logics remain intact while the extracted <code class="highlighter-rouge">aspect</code>s take all responsibilities.</p>

<p>AOP is capable of doing something like this: “Print a warning log to console for every java methods processing POST requests in all controllers”. Like I said the extracted entity doing the job is called <code class="highlighter-rouge">aspect</code>, the predicate describing “every java methods processing POST requests of all controllers” is called pointcut, and the action “print a warning log to console” is called <code class="highlighter-rouge">advice</code>.</p>

<p><code class="highlighter-rouge">AspectJ</code> is the founding predecessor of AOP in Java world, Spring AOP reuses some annotations, but implements on its own, and the core tech it uses is <code class="highlighter-rouge">AOP Proxy</code>. For example, we have an interface and one implementation called <code class="highlighter-rouge">SimplePojo</code>, calling <code class="highlighter-rouge">SimplePojo</code>’s <code class="highlighter-rouge">foo()</code> method looks like this:</p>

<p><img src="/assets/images/aop-proxy-plain-pojo-call.png" alt="Plain POJO call without Proxy" /></p>

<p>And if we create a proxy for <code class="highlighter-rouge">SimplePojo</code>, it looks like this:</p>

<p><img src="/assets/images/aop-proxy-call.png" alt="AOPproxy" />
(Both images come from Spring official documentation)</p>

<p>That being said, the proxy proxies the original method calling, and we can execute our <code class="highlighter-rouge">advice</code> inside the proxy. The following code demonstrates how to create a <code class="highlighter-rouge">proxy</code> with Spring AOP’s lower-level APIs.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">I</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">m</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"m in C"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="kd">extends</span> <span class="n">I</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">m</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">m2</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">proxyDemo</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ProxyFactory</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyFactory</span><span class="o">();</span>

        <span class="n">result</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="n">result</span><span class="o">.</span><span class="na">setInterfaces</span><span class="o">(</span><span class="n">I2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAdvice</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"m2"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"m2 in proxy"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">().</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">invoke</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">I2</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">I2</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m</span><span class="o">());</span>   <span class="c1">//Output: `m in C'</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m2</span><span class="o">());</span>  <span class="c1">//Output: `m2 in proxy'</span>
    <span class="o">}</span></code></pre></figure>

<p>Here are explanations:
- I declared an interface <code class="highlighter-rouge">I</code>
- I defined a class <code class="highlighter-rouge">C</code> inheriting interface <code class="highlighter-rouge">I</code>, and within which I also defined a method <code class="highlighter-rouge">m</code>
- Interface <code class="highlighter-rouge">I2</code> inherits interface <code class="highlighter-rouge">I</code>, and I declared 2 methods (<code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">m2</code>) in it
- <code class="highlighter-rouge">ProxyFactory</code> is Spring AOP’s factory class for proxy. I instantiated it, set its target to an object of <code class="highlighter-rouge">C</code>, set proxied interface to <code class="highlighter-rouge">I2</code>, and added a method interceptor
- <code class="highlighter-rouge">MethodInterceptor</code> is an interface, the overridden method <code class="highlighter-rouge">invoke</code> does the actual work, which in our case are: a) intercepts method call to <code class="highlighter-rouge">m2</code>, return String <code class="highlighter-rouge">m2 in proxy</code>, and b) redirects all other method call (just <code class="highlighter-rouge">m</code> in our case) to the target (a <code class="highlighter-rouge">C</code> object in our case)</p>

<p><br />
After a brief introduction to Spring AOP proxy, now I can partly answer the question I asked in the beginning: why we can call methods we declared in interfaces without implementations? Actually the demo above is a simplified version of Spring Data JPA implementation.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>For Spring Data JPA, when we declare an interface like above, Spring firstly creates a bean named <code class="highlighter-rouge">itemRepository</code>, and it, of course, is a proxy, which is initialized and configured in <code class="highlighter-rouge">RepositoryFactorySupport</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177">3</a>]</sup>. The <code class="highlighter-rouge">target</code> of this proxy is <code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java">4</a>]</sup>, it contains basic CRUD methods like <code class="highlighter-rouge">save()</code>, and <code class="highlighter-rouge">delete()</code> etc by using <code class="highlighter-rouge">EntityManager</code>. The proxied interfaces are <code class="highlighter-rouge">ItemRepository</code> and <code class="highlighter-rouge">Repository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190">5</a>]</sup>. There are multiple method interceptors in the proxy, the one deal with Query Method is <a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375">this one</a>, what it does is iterating all query methods in <code class="highlighter-rouge">ItemRepository</code>, creating a <code class="highlighter-rouge">RepositoryQuery</code> object for each of them and add to a map<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415">7</a>]</sup>.</p>

<p>Once our code invoke <code class="highlighter-rouge">itemRepository.findByName()</code>, the thread immediately goes into <code class="highlighter-rouge">invoke</code> method of the method interceptor<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438">8</a>]</sup>. The interceptor judges if the method we are calling is query method<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">9</a>]</sup> at first, if it is, fetch <code class="highlighter-rouge">RepositoryQuery</code> and execute with parameters, otherwise just call corresponding methods in <code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467">10</a>]</sup>.</p>

<h3 id="mini-parser">Mini Parser</h3>

<p>Now let’s move on to the 2nd part of the question: how does Spring find out our intention and complement implementation details only by the declared method name <code class="highlighter-rouge">findByName</code>?</p>

<p>It’s not magic at all if we take a deeper thought into it, since we need to comply to certain rules when composing query methods<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">11</a>]</sup>, the exact same rules which can be used by Spring to parse and generate JPA query objects. The entry point for parsing is here<sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95">12</a>]</sup>, and the  object generated to interact with database is <code class="highlighter-rouge">RepositoryQuery</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415">7</a>]</sup>.</p>

<p>This mini parser is a hand-written, top-down parser, nothing fancy, no BNF expressions, no parser generators. The topmost node class is <code class="highlighter-rouge">PartTree</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76">13</a>]</sup>, which contains 2 child nodes <code class="highlighter-rouge">subject</code> and <code class="highlighter-rouge">predict</code>. <code class="highlighter-rouge">subject</code> represents query results you want, and <code class="highlighter-rouge">predicate</code> represents conditions just like what it means. For <code class="highlighter-rouge">findByName</code>, <code class="highlighter-rouge">subject</code> is empty and <code class="highlighter-rouge">predicate</code> is <code class="highlighter-rouge">Name</code>; and for more complicated one like <code class="highlighter-rouge">findDistinctUserByNameOrderByAge</code>, subject is <code class="highlighter-rouge">DistinctUser</code> while predicate is <code class="highlighter-rouge">NameOrderByAge</code>.</p>

<p><code class="highlighter-rouge">Subject</code> class has 3 boolean fields: <code class="highlighter-rouge">distinct</code>, <code class="highlighter-rouge">count</code>, <code class="highlighter-rouge">delete</code>, and a integer field <code class="highlighter-rouge">maxResults</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275">14</a>]</sup>. <code class="highlighter-rouge">query</code> is true if query method starts with <code class="highlighter-rouge">findDistinct</code>, count methods set <code class="highlighter-rouge">count</code> to true, the same for <code class="highlighter-rouge">delete</code>, and <code class="highlighter-rouge">maxResults</code> holds the value for limiting queries like <code class="highlighter-rouge">findFirst10ByLastname</code>.</p>

<p><code class="highlighter-rouge">Predicate</code> has an ArrayList <code class="highlighter-rouge">nodes</code> which contains all <code class="highlighter-rouge">OrPart</code> nodes for query method name split by <code class="highlighter-rouge">Or</code>, as you can see this is how and-or-precedence implemented. And there is also an <code class="highlighter-rouge">orderBySource</code> node contains sorting nodes<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L342">15</a>]</sup>.</p>

<p>I am not going further, since it’s just trivial parser implementations. And this is the AST for a relatively long query method <code class="highlighter-rouge">findDistinctByStateAndCountryLikeOrMapAllIgnoringCaseOrderByNameDesc</code>:</p>

<p><img src="/assets/images/ast-of-a-long-query-method.png" alt="AST of a long Query Method" /></p>

<p>Once Spring has the AST, Spring Data will call JPA interfaces to create objects like <code class="highlighter-rouge">Predicate</code> and <code class="highlighter-rouge">CriteriaQuery</code>, then hand them over to JPA to query the database<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98">16</a>]</sup>.</p>

<p>The rules and the parser are extremely simple and crude, ambiguities are very common, nonetheless, it’s totally acceptable since it’s just a helping tool. If ambiguous situations occur, just rename the field name, or, use named query<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries">17</a>]</sup> instead.</p>

<h3 id="references">References</h3>

<ul>
  <li>[1]https://post.lxd.me/2017-03-17-spring-introduction-en/</li>
  <li>[2]https://en.wikipedia.org/wiki/Inversion_of_control</li>
  <li>[3]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177</li>
  <li>[4]https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java</li>
  <li>[5]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190</li>
  <li>[6]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375</li>
  <li>[7]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L415</li>
  <li>[8]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438</li>
  <li>[9]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[10](https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467</li>
  <li>[11]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[12]https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95</li>
  <li>[13]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76</li>
  <li>[14]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275</li>
  <li>[15]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L342</li>
  <li>[16](https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98</li>
  <li>[17]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Spring Introduction</title>
	  <link>//spring-introduction-en</link>
	  <author> </author>
	  <pubDate>2017-03-17T20:34:56+08:00</pubDate>
	  <guid>//spring-introduction-en</guid>
	  <description><![CDATA[
	     <p>This article is a recap of a presentation I gave to my teammates, a brief introduction to Spring framework and related concepts, and 3 common Spring projects (Spring MVC, Spring Data JAP, and Spring Boot).</p>

<h3 id="spring-and-java-ee">Spring and Java EE</h3>

<p><img src="/assets/images/spring-java-ee.png" alt="Spring and Java EE" /></p>

<p>Let’s talk a bit about Java first. Java has multiple <strong>edition</strong>s: Java SE, Java EE and Java ME. Java SE and Java EE are closely related to Spring framework. Java SE (Java Platform, Standard Edition) contains JVM and all core libraries and APIs, while Java EE (Java Platform, Enterprise Edition) is a set of specifications and APIs which will be used to develop large-scale enterprise applications, such as <code class="highlighter-rouge">servlet specification</code> used to handle HTTP request and <code class="highlighter-rouge">JPA</code> describes the management of relational database. Java EE constitutes of JSRs (Java Specification Request) maintained by JCP (Java Community Process), just like RFC to IETF.</p>

<p>There are several Java EE implementations in the industry, all belong to IT giants, like IBM’s WebSphere Application Server (WAS), Oracle’s WebLogic, and JBoss which belongs to RedHat. They all comply to Java EE standards, and they all implement most of Java EE specifications like Servlet and JPA, and they mostly are called <code class="highlighter-rouge">Application Server</code>s since Java EE makes sure our applications can run upon. The open source alternatives of these application servers like Tomcat or Jetty are called <code class="highlighter-rouge">Web Container</code>, since they only implement Web related specifications such as Server spec and JSP specs. If we need dependency injection we bring in Spring, if we need to interact with relational databases, we bring in Hibernate.</p>

<p>And strictly speaking, Spring is not an implementation of Java EE, since even she does implement lower level Java EE specs like Servlet and JPA, but she uses its own stuff for higher level APIs like dependency injection and RESTful web service. Java EE specs for dependency injection is CDI while Spring uses Spring DI, and for REST it’s JAX-RS vs Spring MVC.</p>

<h3 id="spring-ioc--di">Spring IoC / DI</h3>
<p>At its core, the foundation concept of Spring Framework is DI (Dependency Injection) or a.k.a. IoC (Inversion of Control). These 2 abbreviations are really novice-unfriendly, and so require some explanations.</p>

<p>IoC is a theory, a technology, not only exist in Spring. Generally speaking, for some entity, the work/flow which this entity should initiate, turns out to this entity passively receive, this active-passive turnover is IoC. For example you want to write a small trivial program at work, at the beginning it’s a small program calling some 3rd party libraries, this is the active role your code is playing, as your trivial program grew bigger you import a framework to sort things out, your code becomes callbacks or interface implementations, now your code plays the passive role. With the help of IoC we can achieve decoupling, free our hands by relieving responsibilities.</p>

<p>For Spring IoC, it’s the responsibility of object instantiation and dependency tree maintenance that being shifted from our hands to Spring.  For example, when we write Java application without Spring IoC, it could be like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="o">();</span>

    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setB</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span><span class="o">());</span></code></pre></figure>

<p>It’s class A depends on Class B and Class C, we pass the objects of A and B through constructor and setter function. With the help of Spring IoC and some other Spring tricks, it could be like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">@Component</code> annotations tell Spring the annotated classes need to be instantiated as beans, which are Java objects managed by Spring, while <code class="highlighter-rouge">@Autowired</code> annotations tell Spring to inject the type-matched beans to the annotated fields, and this is duly <code class="highlighter-rouge">dependency injection</code>.</p>

<h3 id="web-container">Web container</h3>
<p>Web container a.k.a. Servlet container is different from Web Server. Nginx and Apache are web servers, which mainly handle HTTP requests. Web containers like Tomcat, Jetty or GlassFish, however, are like fish tanks where Java Servlets live in. Application Server I mention above can be considered as a superset of Web container, since it’s capable of more than containing servlets. Almost all Java Web applications we write in the end are a bunch of servlets or facaded by servlets, these servlets cannot run on their own, neither can they directly handle HTTP requests. They need to be managed by Web containers, and web containers dispatch HTTP requests to servlets based on mapping rules, like below:</p>

<p><img src="/assets/images/servlet-container.png" alt="Servlet" /></p>

<p>The whole process is Java EE spec, which Web containers, application servers, and Java Web applications should all follow, so we can deploy our applications to any Web containers or application servers with minor adaptation.</p>

<h3 id="spring-mvc">Spring MVC</h3>
<p>Spring framework consists of many modules, spring-core and spring-beans are at at core, spring-jdbc and spring-orm are responsible for database interaction etc. It’s too common to use Spring to build backend RESTful APIs, so it’s necessary to give a quick view of Spring Web MVC module.</p>

<p>As I stated before you cannot get away with servlets for HTTP in Java, Spring MVC is tangled with servlet as well. Spring MVC is facaded by <code class="highlighter-rouge">DispatchServlet</code> which accepts all HTTP requests and then dispatch to other HTTP endpoints in your application. The following is an HTTP endpoint demo with Spring MVC:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/stores/{storeId}/items"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemController</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/{itemId}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="n">produces</span> <span class="o">=</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_UTF8_VALUE</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Item</span> <span class="n">retrieveItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">storeId</span><span class="o">,</span> <span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">itemId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">ResponseEntity</span> <span class="n">createItem</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">@RestController</code> is annotated on Java Class, which means annotated Class is a RESTful API endpoint, hence the Controller in MVC architecture. All Controllers and RestControllers are Spring-managed beans as well.</li>
  <li><code class="highlighter-rouge">@RequestMapping</code> defines URL routing mapping rules, the one annotated on Class can specify absolute path while the one annotated on method specify the relative path. And methods annotated with <code class="highlighter-rouge">@RequestMapping</code> are responsible for handle HTTP requests and serve responses.</li>
  <li>Paths specified by <code class="highlighter-rouge">@RequestMapping</code> comply with URL Template<sup>[<a href="https://tools.ietf.org/html/rfc6570">1</a>]</sup> and <code class="highlighter-rouge">@PathVariable</code> can extract variable values in it.</li>
  <li>By annotating <code class="highlighter-rouge">@RequestBody</code> on method parameters, Spring will convert HTTP request body to Java object and inject to annotated parameters. And Spring also will convert method return value to HTTP response in JSON format, since class is annotated with <code class="highlighter-rouge">@RestController</code></li>
  <li><code class="highlighter-rouge">ResponseEntity</code> is a generic class containing HTTP response body, and HTTP headers and status code which you can tweak. In this demo the method responds empty body with status code specified to 200.</li>
</ul>

<p>With an extremely simplified Class Item, the terminal should look like this if we call the RESTful API with cURL</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ curl -v http://localhost:8080/stores/16/items/1
...
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Type: application/json;charset=UTF-8
...

{"name":"hehe"}%</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">curl -v -H "Content-Type: application/json" -i -X POST -d '{"name":"haha"}' http://localhost:8080/stores/16/items
...
&gt; Content-Type: application/json
&gt; Content-Length: 15
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Length: 0
...</code></pre></figure>

<h3 id="spring-data-jpa">Spring Data JPA</h3>
<p>Spring has always been considered a framework, but in recent years it’s more like a portfolio, contains dozens of <a href="https://spring.io/projects">projects</a>, all based on original Spring framework but provide various abundant features, Spring Data is one of them. Spring Data provides consistent, elegant, and easy-to-use interfaces to access persistent facilities, and Spring Data JPA is one of the modules specifically deal with relational databases. As we can see soon, Spring Data JPA provides a set of very tidy interfaces for us to implement routine CRUDs.</p>

<p>Spring Data JPA exposes a bunch of Java interfaces to users, behind the scenes it uses Dynamic Proxy AOP to inject actual work in runtime. The interface at the top is <code class="highlighter-rouge">Repository&lt;T, ID extends Serializable&gt;</code>, then it’s <code class="highlighter-rouge">CrudRepository&lt;T, ID extends Serializable&gt;</code> providing basic CRUD operations, and <code class="highlighter-rouge">JpaRepository&lt;T, ID extends Serializable&gt;</code> with JPA related actions etc. They all generic interfaces whose first type parameter is entity class corresponding to a database table, and the 2nd parameter is the type of ID in the entity class. To use Spring Data JPA all we need is create an interface extends one of these interfaces and then declare methods we will be calling in it.</p>

<p>The following example demonstrates how Spring Data JPA simplifies the process of exposing CRUD interfaces to a simple data entity.</p>

<p>Given the table structure and Entity class:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">item</span> <span class="p">(</span>
  <span class="n">id</span>          <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">name</span>        <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">description</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">itemPk</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">generator</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">)</span>
    <span class="nd">@GenericGenerator</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">,</span> <span class="n">strategy</span> <span class="o">=</span> <span class="s">"uuid2"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">description</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">description</span> <span class="o">=</span> <span class="n">description</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">description</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Firstly we declare an interface extends <code class="highlighter-rouge">CrudRepository</code>, and designate type parameter explicitly</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<p>Since <code class="highlighter-rouge">CrudRepository</code> already has common CRUD methods like <code class="highlighter-rouge">save(S entity)</code>, <code class="highlighter-rouge">findOne(ID id)</code>, <code class="highlighter-rouge">exists(ID id)</code> and <code class="highlighter-rouge">delete(ID id)</code>, so now we only need to fill in some query methods specific to our need, as long as follow naming conventions[1]. For example, if we’d like to find all items with the same name, we can declare <code class="highlighter-rouge">findByName</code> <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">here</a></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Inject <code class="highlighter-rouge">ItemRepository</code> to wherever we need, then we are able to call these CURD methods directly.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClient</span> <span class="o">{</span>
  <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">ItemRepository</span> <span class="n">itemRepository</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomething</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="s">"teapot"</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomethingElse</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Item</span> <span class="n">newItem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Item</span><span class="o">(</span><span class="s">"smug"</span><span class="o">,</span> <span class="s">"smug without mug"</span><span class="o">);</span>
    <span class="n">itemRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">newItem</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>User-defined query method mimics Rails <a href="http://guides.rubyonrails.org/active_record_querying.html#dynamic-finders">Dynamic Finders</a> and it supports more sophisticated combinations like and, or, pagination, limit, asc/desc etc, you can refer to official documentation here[2].</p>

<p>How does Spring Data JPA do all the magic tricks? Well, it’s not that magic for Spring core. During Spring application bootup, Spring creates a proxy bean for <code class="highlighter-rouge">ItemRepository</code> interface at first with the help of Spring AOP, then in that proxy Spring parses all user-defined query method names and store ASTs on the bean. When these query methods get called in runtime, Spring AOP intercepts the method call, fetch the AST, assemble into a Query object combined with query parameters, then hand over to JPA. I give a more thorough analysis in <a href="/spring-data-jpa-internals-en">another post</a>.</p>

<h3 id="spring-boot">Spring Boot</h3>

<p>Spring Boot is another Spring project, a Convention over Configuration follower and a relatively successful one. It has done a lot of work based on Spring which makes it much easier to build a Spring application.</p>

<p>In old days we need to list all depending artifacts in pom.xml or gradle.build, which is really annoying and cumbersome, Spring Boot thoughtfully gives us <code class="highlighter-rouge">Spring Boot Starters</code>, a one-stop-shop for all the Spring and related technology. It organizes related dependencies into groups from a Spring user’s perspective, we only need to include the group dependency descriptor artifactId in our pom.xml or build.gradle. For example when we develop a Spring Web application, generally we need to import Spring MVC, spring-web module, and Jackson etc, with Spring Boot we just import <code class="highlighter-rouge">spring-boot-starter-web</code> once for all. The same goes to <code class="highlighter-rouge">spring-boot-starter-test</code> which includes JUnit, Hamcrest and Mockito; and <code class="highlighter-rouge">spring-boot-starter-data-jpa</code> which includes everything related to relational database interaction.</p>

<p>Like I said before Spring Web applications need to put into Servlet containers in order to run, however, <code class="highlighter-rouge">spring-boot-starter-web</code> starter includes an embedded Tomcat, which can be started through <code class="highlighter-rouge">SpringApplication.run()</code> within our code in main function. In this way, our Spring Web applications are directly runnable via commandline, or IDE, or <code class="highlighter-rouge">java -jar</code> after packaged into a independent jar file.</p>

<p>Spring Boot also has fine-tuned a lot of details to keep to Convention over Configuration. Hibernate has <code class="highlighter-rouge">ImprovedNamingStrategy</code> class automatically map camelCase field names in Entity class to snake_case field names in DB tables, however it doesn’t support foreign keys. Spring Boot provides <code class="highlighter-rouge">SpringNamingStrategy</code> which inherits <code class="highlighter-rouge">ImprovedNamingStrategy</code> and adds foreign keys support.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Spring Data JPA 技术分析</title>
	  <link>//spring-data-jpa-internals</link>
	  <author> </author>
	  <pubDate>2015-12-07T20:34:56+08:00</pubDate>
	  <guid>//spring-data-jpa-internals</guid>
	  <description><![CDATA[
	     <p>在另一篇介绍Spring的文章<sup>[<a href="/spring-introduction">1</a>]</sup>里我介绍了Spring Data JPA，借助Spring Data JPA，对数据库做CRUD需要简单的四步操作：先创建数据库表和Java entity类；声明一个接口<code class="highlighter-rouge">ItemRepository</code>继承<code class="highlighter-rouge">CrudRepository</code>；再在接口<code class="highlighter-rouge">ItemRepository</code>里声明Query Method<code class="highlighter-rouge">findByName</code>；最后把<code class="highlighter-rouge">ItemRepository</code>注入到我们需要用到的地方，调用就可以了。</p>

<p>这篇文章再深入一点，解释/分析一下Spring在背后做了什么；为什么作为一个Spring用户，我们声明一个接口，在接口里声明一个方法，我们就可以调用这个方法了操作数据库了？</p>

<p>先从Spring AOP说起。</p>

<h3 id="spring-aop-proxy">Spring AOP Proxy</h3>

<p>AOP（面向切面编程，Aspect-Oriented Programming），是Java里常用的一个编程范式。OOP对逻辑和数据做了一定程度的封装，但是当应用运行起来之后，从数据流的角度来看，数据是从一个类实例流到另一个实例，是链式的，我们编写的业务逻辑也是在一条条调用链上做文章。而AOP则是从另一个维度做文章：比如说原来的模块划分，或者调用链是纵向的，那么AOP是从横向切入，把纵向维度中共性的部分，比如logging、auth、cache，抽取出来，并且用IoC<sup>[<a href="https://en.wikipedia.org/wiki/Inversion_of_control">2</a>]</sup>的思想，由抽取出来的<code class="highlighter-rouge">aspect</code>承担匹配和执行的责任，原来的业务逻辑不需要添加/改动任何代码。</p>

<p>举例来说，AOP可以做这样的事情：“让一个Web应用中所有Controller的POST方法执行之前打一条log”。抽取出来做这件事情的模块称为<code class="highlighter-rouge">aspect</code>，描述匹配到“所有Controller的POST方法”的谓词称为<code class="highlighter-rouge">pointcut</code>，“打log”这样的行为称为<code class="highlighter-rouge">advice</code>。</p>

<p>AspectJ是这个Java里AOP鼻祖老爷，Spring AOP兼容了一部分AspectJ的annotation，但核心还是Spring自己的，这个核心就是AOP proxy。比如我们有一个接口<code class="highlighter-rouge">Pojo</code>和它的实现<code class="highlighter-rouge">SimplePojo</code>，当没有proxy的时候，调用<code class="highlighter-rouge">SimplePojo</code>的<code class="highlighter-rouge">foo</code>方法是这样的：</p>

<p><img src="/assets/images/aop-proxy-plain-pojo-call.png" alt="Plain POJO call without Proxy" /></p>

<p>当我们创建一个<code class="highlighter-rouge">SimplePojo</code>的proxy之后，调用这个proxy的<code class="highlighter-rouge">foo</code>方法的是这样的：</p>

<p><img src="/assets/images/aop-proxy-call.png" alt="AOPproxy" />
（两张图片都来自Spring官方文档）</p>

<p>即proxy“代理”了对原对象原方法的调用，在这个代理的过程中我们可以执行<code class="highlighter-rouge">advice</code>，比如Spring AOP中的方法拦截器。下面的代码演示了如何用Spring AOP的底层API创建一个proxy。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">I</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">m</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"m in C"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">I2</span> <span class="kd">extends</span> <span class="n">I</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">m</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">m2</span><span class="o">();</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">proxyDemo</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ProxyFactory</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProxyFactory</span><span class="o">();</span>

        <span class="n">result</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="n">C</span><span class="o">());</span>
        <span class="n">result</span><span class="o">.</span><span class="na">setInterfaces</span><span class="o">(</span><span class="n">I2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">addAdvice</span><span class="o">(</span><span class="k">new</span> <span class="n">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"m2"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="s">"m2 in proxy"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">().</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">invoke</span><span class="o">(</span><span class="n">invocation</span><span class="o">.</span><span class="na">getThis</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">I2</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">I2</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m</span><span class="o">());</span>   <span class="c1">//Output: `m in C'</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">m2</span><span class="o">());</span>  <span class="c1">//Output: `m2 in proxy'</span>
    <span class="o">}</span></code></pre></figure>

<p>首先声明一个接口<code class="highlighter-rouge">I</code>；类<code class="highlighter-rouge">C</code>实现接口<code class="highlighter-rouge">I</code>的同时自己定义了一个方法<code class="highlighter-rouge">m()</code>；接口<code class="highlighter-rouge">I2</code>继承<code class="highlighter-rouge">I</code>并声明了方法<code class="highlighter-rouge">m()</code>和方法<code class="highlighter-rouge">m2()</code>。ProxyFactory是Spring AOP的proxy工厂类，实例化之后，设置proxy的target为<code class="highlighter-rouge">C</code>的实例，要代理的接口为<code class="highlighter-rouge">I2</code>，然后添加一个方法拦截器。</p>

<p>方法拦截器是一个接口，我们实例化的匿名内部类的<code class="highlighter-rouge">invoke()</code>方法就是这个拦截器的回调。当调用的方法名字是<code class="highlighter-rouge">m2</code>的时候，拦截器直接返回一个字符串<code class="highlighter-rouge">m2 in proxy</code>。当调用的方法名字是<code class="highlighter-rouge">m</code>的时候，通过反射获取到target（<code class="highlighter-rouge">C</code>的实例）的<code class="highlighter-rouge">m()</code>方法，调用执行。
<br />
介绍了Spring AOP Proxy之后，就可以解释一开始那个问题的前半部分了——为什么在我们只声明了一个接口和方法的情况下，这个方法可以被调用到？事实上上面的demo已经基本上了回答了这个问题，接下来我把各部分逻辑对应到Spring Data JPA上。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Spring在创建的名为<code class="highlighter-rouge">itemRepository</code>的bean，就是一个proxy，这个proxy在<code class="highlighter-rouge">RepositoryFactorySupport</code>里完成了初始化和配置<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177">3</a>]</sup>；Proxy的target是<code class="highlighter-rouge">SimpleJpaRepository</code><sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java">4</a>]</sup>，它用<code class="highlighter-rouge">EntityManager</code>实现了<code class="highlighter-rouge">CrudRepository</code>里的基本CRUD方法；Proxy的代理接口即<code class="highlighter-rouge">ItemRepository</code>和<code class="highlighter-rouge">Repository</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190">5</a>]</sup>；Proxy添加了多个方法拦截器，处理自定义Query Method的拦截器是<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375">6</a>]</sup>，这个拦截器在构造函数里遍历<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象放到一个map中<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>。</p>

<p>当我们的代码调用到<code class="highlighter-rouge">itemRepository.findByName()</code>的时候，即进入到方法拦截器的<code class="highlighter-rouge">invoke</code>方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438">8</a>]</sup>，拦截器首先判断是不是Query Method<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">9</a>]</sup>，如果是的话就取出<code class="highlighter-rouge">RepositoryQuery</code>对象带参数执行，不是的话调用<code class="highlighter-rouge">SimpleJpaRepository</code>里的方法<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467">10</a>]</sup>。</p>

<h3 id="mini-parser">Mini Parser</h3>

<p>下面接着继续分析开题问题的第二部分，为什么我们只声明一个<code class="highlighter-rouge">findByName</code>的方法，Spring就知道如何去查询数据库了？</p>

<p>事实上细细想来这个并不特别神奇，我们在声明query methods的时候，是需要遵循规范的<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">11</a>]</sup>，既然我们定义方法遵循了规范，Spring基于同样的规范，用一个parser解析这个方法名，就能生成JPA的查询对象。</p>

<p>我们在前面提到Spring会根据<code class="highlighter-rouge">ItemRepository</code>里的Query Method，创建一个<code class="highlighter-rouge">RepositoryQuery</code>对象<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461">7</a>]</sup>，这个对象就是一个迷你的parser解析query method方法名的结果，解析的入口在<sup>[<a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95">12</a>]</sup>。</p>

<p>这个mini parser是自顶向下解析的，最顶上的节点类是<code class="highlighter-rouge">PartTree</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76">13</a>]</sup>，它包含两个字段/子节点，<code class="highlighter-rouge">subject</code>和<code class="highlighter-rouge">predicate</code>。<code class="highlighter-rouge">subject</code>表示要查询的结果，<code class="highlighter-rouge">predicate</code>表示查询的条件。比如对于<code class="highlighter-rouge">findByName</code>，<code class="highlighter-rouge">subject</code>为空，<code class="highlighter-rouge">predicate</code>为<code class="highlighter-rouge">Name</code>；再比如稍微复杂一点的<code class="highlighter-rouge">findDistinctUserByNameOrderByAge</code>，subject是<code class="highlighter-rouge">DistinctUser</code>，predicate是<code class="highlighter-rouge">NameOrderByAge</code>。</p>

<p><code class="highlighter-rouge">Subject</code>有3个boolean属性，分别是<code class="highlighter-rouge">distinct</code>，<code class="highlighter-rouge">count</code>，<code class="highlighter-rouge">delete</code>，<code class="highlighter-rouge">maxResults</code><sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275">14</a>]</sup>，如果query带了<code class="highlighter-rouge">Distinct</code><code class="highlighter-rouge">distinct</code>就是true，count方法<code class="highlighter-rouge">count</code>为true，delete方法<code class="highlighter-rouge">delete</code>为true。<code class="highlighter-rouge">maxResults</code>是limit查询的值，如<code class="highlighter-rouge">findFirst10ByLastname</code>。</p>

<p><code class="highlighter-rouge">Predicate</code>有一个ArrayList<code class="highlighter-rouge">nodes</code>包含以<code class="highlighter-rouge">Or</code>split后的节点<code class="highlighter-rouge">OrPart</code>，还有一个<code class="highlighter-rouge">orderBySource</code>包含用<code class="highlighter-rouge">OrderBy</code>split的排序节点<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345">15</a>]</sup>。</p>

<p>……</p>

<p><code class="highlighter-rouge">OrPart</code>节点往后不再赘述推导规则了，最后，定义一个比较复杂的方法看一下AST。对于<code class="highlighter-rouge">findDistinctByStateAndCountryLikeOrMapAllIgnoringCaseOrderByNameDesc</code>，AST如下图</p>

<p><img src="/assets/images/ast-of-a-long-query-method.png" alt="AST of a long Query Method" /></p>

<p>有了AST之后，Spring Data再调用JPA的接口创建<code class="highlighter-rouge">Predicate</code>对象、<code class="highlighter-rouge">CriteriaQuery</code>对象等，交给JPA查询DB<sup>[<a href="https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98">16</a>]</sup>。</p>

<p>这个规则和parser都很简陋，很容易出现二义的情况，如果遇到这样的情况，就不一定非要苦苦纠结于解析规则了，它目的毕竟还是为了给用户提供方便，如果不能很方便的提供方便，那就给字段改个名儿，或者改用Named Query<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries">17</a>]</sup>。</p>

<p><br /><br /></p>

<p>参考资料：</p>

<ul>
  <li>http://docs.spring.io/spring-data/jpa/docs/current/reference/html/</li>
  <li>http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html</li>
  <li>[1]http://post.lxd.me/2015-12-01-spring-introduction/</li>
  <li>[2]（控制反转的思想，不特指Spring DI） https://en.wikipedia.org/wiki/Inversion_of_control</li>
  <li>[3]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L177</li>
  <li>[4]https://github.com/spring-projects/spring-data-jpa/blob/fda74889de51e586bfa22033aed0affb6f7f4c76/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java</li>
  <li>[5]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L190</li>
  <li>[6]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L375</li>
  <li>[7]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[8]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L438</li>
  <li>[9]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L461</li>
  <li>[10]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/core/support/RepositoryFactorySupport.java#L467</li>
  <li>[11]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[12]https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/query/JpaQueryLookupStrategy.java#L95</li>
  <li>[13]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L76</li>
  <li>[14]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L275</li>
  <li>[15]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/PartTree.java#L345</li>
  <li>[17]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.named-queries</li>
  <li>[16]https://github.com/spring-projects/spring-data-commons/blob/01f2c30b1d1c342e168b3b541974332cc429e3e2/src/main/java/org/springframework/data/repository/query/parser/AbstractQueryCreator.java#L98</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Spring 介绍</title>
	  <link>//spring-introduction</link>
	  <author> </author>
	  <pubDate>2015-12-01T20:34:56+08:00</pubDate>
	  <guid>//spring-introduction</guid>
	  <description><![CDATA[
	     <p>这篇文章对Spring Framework做一个基础的介绍，先介绍Spring和Spring相关的几个概念，再介绍3个常用的Spring项目/模块：Spring MVC、Spring Data JPA、和Spring Boot。</p>

<h3 id="spring--java-ee">Spring 和 Java EE</h3>

<p><img src="/assets/images/spring-java-ee.png" alt="Spring and Java EE" /></p>

<p>Java平台有多个“版本”，和Spring相关的有两个：Java SE和Java EE。Java SE（Java Platform, Standard Edition）包含JVM和Java最核心/基本的类库API；而Java EE（Java Platform, Enterprise Edition）是在Java SE之上，定义的一套specifications，用来支持所谓的Enterprise/企业级开发，比如用来接受处理HTTP请求的servlet specification、和关系型数据库交互的API（JPA）等。Java EE定义的每一条规范称为JSR（Java Specification Request），由JCP（Java Community Process）开发维护，就像RFC之于IETF。</p>

<p>有标准就有实现，基于Java EE的标准，业界有好些个实现，这些实现基本都是“大公司”的产品，比如IBM的WebSphere Application Server（WAS），Oracle的WebLogic，RedHat的JBoss/WildFly等等，这些实现都遵循Java EE的标准，而且实现了Servlet spec、JPA spec等大部分重要的specification，称为应用服务器（Application Server），Java EE规范保证了我们编写的应用能够部署/运行在上面；而在开源界更常用的Tomcat/Jetty则称为Web容器（Web Container），只实现了Java EE里的Servlet spec、JSP spec等和Web相关的specification，我们如果需要依赖注入，就需要自己引入Spring，需要用JPA访问关系型数据库，就需要自己引入Hibernate。</p>

<p>而且Spring在严格意义上来说并不是Java EE的实现，因为它一方面遵循了Java EE的Servlet、JPA等核心接口，但是对于更上层的API，Spring用的是自己的东西，比如依赖注入（Spring DI vs CDI），RESTful Web Service（Spring MVC vs JAX-RS）。</p>

<h3 id="spring-ioc--di">Spring IoC / DI</h3>

<p>Spring框架最核心的概念就是它基于控制反转技术（Inversion of Control - IoC）的依赖注入（Dependency Injection - DI），这两个狰狞的名词到底是什么意思？我简单描述一下。</p>

<p>抛开Spring，IoC是一种思想，一种技术，即对于一个主体而言，原来由他主动负责/发起的工作，变成了由它被动接受，这个由主动变被动的过程，称为IoC。比如library和framework就是一个很典型的好例子：当我们使用library，我们编写的代码调用lib，我们是主动方、发起方；而当我们改用framework，我们编写的代码则作为framework的回调、实现、或被托管对象，我们从主动方变成了被动方。通过IoC，我们可以解耦，可以解除主体的责任，可以解放自己。</p>

<p>Spring IoC（a.k.a. Spring DI）就是IoC在Spring里的一个应用，它把本来应该由我们自己写代码主动负责的对象实例化和依赖引用的过程，交由Spring来完成，举个例子：</p>

<p>在不借助DI，我们用Java写一个application的时候，如果Class A依赖于Class B和Class C，我们可以把B的实例由构造函数/setter函数传进去，C的实例由A自己实例化一个出来，就像这样：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span><span class="o">();</span>

    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setB</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="o">(</span><span class="k">new</span> <span class="n">B</span><span class="o">());</span></code></pre></figure>

<p>借助Spring DI和其他一些技术，可以这样：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">C</span> <span class="n">c</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="n">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>这里步子跨的有点大，<code class="highlighter-rouge">@Component</code>标签告诉Spring这个类需要被实例化为一个bean，bean是由Spring管理的一个Java对象实例，所以在这里Class A B C都会被Spring实例化为bean。<code class="highlighter-rouge">@Autowired</code>标签告诉Spring去寻找一个类型匹配的bean注入到该字段/方法，形成对B和C的引用，这便是<u>依赖注入</u>。</p>

<p>所以，本来应该由的代码负责的，把B和C的实例交给A的实例引用的过程，变成了在代码中只声明依赖，由Spring完成实例化和实例之间的引用，这就是IoC — Inversion of Control——<u>控制反转</u>。</p>

<h3 id="web-container">Web Container</h3>

<p>Web Container，Web容器，也叫Servlet容器。我们用Spring构建的Web应用是要借助一个容器来运行的，比如Tomcat、Jetty，GlassFish。因为无论是用Spring还是其他Java EE框架编写出来的Web应用，都是是一个个独立的servlet，或者基于servlet的东西，这些独立的servlet不能直接运行，也不能直接接收来自浏览器的HTTP请求。Tomcat/Jetty这些容器一方面是一个Web服务器——即和浏览器交互，接收/响应HTTP请求；另一方面是Servlet容器——加载servlet，负责管理他们的生命周期，根据mapping规则把分发给响应的servlet，如下图</p>

<p><img src="/assets/images/servlet-container.png" alt="Servlet" /></p>

<p>这一整套都是Java EE Servlet规范，Spring和容器都得遵守这些规范，用Spring写的Web应用才可以部署到Web容器里去。</p>

<h3 id="spring-mvc">Spring MVC</h3>

<p>Spring框架由诸多模块组成，最核心的有spring-core、spring-beans，和数据库交互的有spring-jdbc、spring-orm等，我们用Spring来构建Web项目比较多，所以介绍一下Spring Web MVC模块。</p>

<p>Servlet是Java EE里处理HTTP请求的技术/规范，Spring MVC也是基于servlet来设计的，基于一个核心的<code class="highlighter-rouge">DispatcherServlet</code>，HTTP请求进来之后由它分发给其他的Controller处理。下面是在Spring里写一个Controller的demo，另外Spring MVC提供了Model-View-Controller的完整功能，但在这前后端分离的年代，就只demo提供RESTful API、返回JSON的Controller写法：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/stores/{storeId}/items"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemController</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/{itemId}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="n">produces</span> <span class="o">=</span> <span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_UTF8_VALUE</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Item</span> <span class="n">retrieveItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">storeId</span><span class="o">,</span> <span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">itemId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">ResponseEntity</span> <span class="n">createItem</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="n">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">@RestController</code>标记在一个Java类上，告诉Spring MVC这是一个RESTful API Controller，所有的Controller同时也都是Spring管理的bean；</li>
  <li><code class="highlighter-rouge">@RequestMapping</code>描述了URL的路由映射。标记在类上的<code class="highlighter-rouge">@RequestMapping</code>定义了顶层的路径，结合在方法上的<code class="highlighter-rouge">@RequestMapping</code>的路径和HTTP method，将一个HTTP请求映射到一个Java方法上，由这个方法来处理HTTP请求，返回HTTP响应。</li>
  <li><code class="highlighter-rouge">@RequestMapping</code>中定义路径的字符串支持URI Template<sup>[<a href="https://tools.ietf.org/html/rfc6570">1</a>]</sup>，路径中{变量}所代表的的值，用<code class="highlighter-rouge">@PathVariable</code>标记在同名的Java方法参数上提取出来。</li>
  <li><code class="highlighter-rouge">@RequestBody</code>标记在Java方法参数上，Spring MVC会自动把HTTP请求转成Java对象，绑定在这个参数上；同样的，因为我们标记了这个类为RESTful Controller，Java方法的返回值会直接转成JSON；</li>
  <li><code class="highlighter-rouge">ResponseEntity</code>是一个泛型类，包装了Controller返回的HTTP response内容，增加了可以控制HTTP响应头、状态码的方法，代码里返回一个空的HTTP响应，状态码设置为200。</li>
</ul>

<p>写一个最简单的Item类，用cURL调用RESTful接口可以看到下面的执行结果：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ curl -v http://localhost:8080/stores/16/items/1
...
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Type: application/json;charset=UTF-8
...

{"name":"hehe"}%</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">curl -v -H "Content-Type: application/json" -i -X POST -d '{"name":"haha"}' http://localhost:8080/stores/16/items
...
&gt; Content-Type: application/json
&gt; Content-Length: 15
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; Content-Length: 0
...</code></pre></figure>

<h3 id="spring-data-jpa">Spring Data JPA</h3>

<p>过去我们谈起Spring是一个framework，但是现在的Spring更多的像一个family/collection，基于核心的Spring Framework之上做了好些project<sup>[<a href="https://spring.io/projects">2</a>]</sup>，Spring Data就是其中之一。Spring Data给数据库的访问提供了一个更优雅/强大的接口，Spring Data JPA是基于JPA、针对关系型数据库的子模块，给我们写应用日常遇到的简单CRUD提供了一个非常干净的接口。</p>

<p>Spring Data / JPA 提供给我们用户的是一系列Java interface，它在背后用基于Dynamic Proxy的AOP帮我们完成了实际的工作。最顶层的<code class="highlighter-rouge">Repository&lt;T, ID extends Serializable&gt;</code>，提供了最基本CRUD操作的<code class="highlighter-rouge">CrudRepository&lt;T, ID extends Serializable&gt;</code>，JPA相关操作的<code class="highlighter-rouge">JpaRepository&lt;T, ID extends Serializable&gt;</code>等。它们都是泛型接口，第一个类型参数是对应到数据库的实体类，第二个参数是实体类里ID的类型。我们声明一个接口继承这些接口，再申明一些我们自己的方法进去，就可以完成大部分简单的数据库操作了。</p>

<p>借助Spring Data JPA，对数据库做简单的CRUD需要四步操作：</p>

<p>第一步，在数据库中创建表，然后创建一个entity类映射它</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">item</span> <span class="p">(</span>
  <span class="n">id</span>          <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">name</span>        <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">description</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="n">itemPk</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">generator</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">)</span>
    <span class="nd">@GenericGenerator</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"uuid"</span><span class="o">,</span> <span class="n">strategy</span> <span class="o">=</span> <span class="s">"uuid2"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Item</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">description</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">description</span> <span class="o">=</span> <span class="n">description</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">description</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>第二步，声明一个接口，继承填入类型参数的<code class="highlighter-rouge">CrudRepository</code>接口</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<p>第三步，<code class="highlighter-rouge">CrudRepository</code>接口里已经声明了一些最基本的CRUD方法<code class="highlighter-rouge">save(S entity)</code>，<code class="highlighter-rouge">findOne(ID id)</code>，<code class="highlighter-rouge">exists(ID id)</code>，<code class="highlighter-rouge">delete(ID id)</code>等，我们可以在声明的接口里再进一步声明一些我们业务上需要的方法，但是要根据一定的命名规则<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">3</a>]</sup>。比如根据<code class="highlighter-rouge">name</code>查找出所有同名的item的方法声明为<code class="highlighter-rouge">findByName</code>。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span> <span class="kd">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">findByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>第四步，把<code class="highlighter-rouge">ItemRepository</code>注入到我们需要用到的地方，调用就可以了</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClient</span> <span class="o">{</span>
  <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="n">ItemRepository</span> <span class="n">itemRepository</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomething</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="s">"teapot"</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomethingElse</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Item</span> <span class="n">newItem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Item</span><span class="o">(</span><span class="s">"smug"</span><span class="o">,</span> <span class="s">"smug without mug"</span><span class="o">);</span>
    <span class="n">itemRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">newItem</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>自定义查询方法除了简单的findBy…以外还可以进行更丰富的组合：and、or、pagination、limit、asc/desc等<sup>[<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation">3</a>]</sup>。</p>

<p>那么Spring Data是怎么做这些magic的？其实这对Spring核心来说来说都不是很困难。首先用基于Dynamic Proxy的Spring AOP，创建一个proxy作为<code class="highlighter-rouge">itemRepository</code>的bean实例，然后解析所有的自定义方法如<code class="highlighter-rouge">findByName</code>，用一个迷你的parser解析方法名，将AST保存在bean上；当应用启动我们的代码调用到<code class="highlighter-rouge">findByName</code>的时候，Spring AOP拦截了方法调用，取出AST，解析成一个Query对象，再结合参数交给JPA实现做查询，我在另外一篇文章<sup>[<a href="http://post.lxd.me/2015-12-07-spring-data-jpa-internals">4</a>]</sup>做了更详细的分析。</p>

<h3 id="spring-boot">Spring Boot</h3>

<p>Spring Boot是另一个Spring project，Convention over Configuration风的追随者。它基于Spring做了很多工作，使得编写一个Spring应用变的非常容易。</p>

<p>以往我们初始化一个Java应用需要在maven/gradle配置文件里历数写上它的依赖，非常繁复，Spring Boot非常体贴的给我们提供了<code class="highlighter-rouge">Start POMs</code>——一站式的jar包依赖解决方案。它从Spring用户的视角，对有关联的、通常会一起使用的第三方依赖做了编组，当我们需要Spring的哪部分功能的时候，在配置文件里写入对应编组的artifactId作为依赖就好了。比如我们需要做Web应用，一般需要Spring MVC的依赖，spring-web模块，Jackson的依赖等，在Spring Boot里我们引入<code class="highlighter-rouge">spring-boot-starter-web</code>就可以了。类似的还有包含JUnit、Hamcrest和Mockito等测试工具的<code class="highlighter-rouge">spring-boot-starter-test</code>，Spring Data JPA相关的<code class="highlighter-rouge">spring-boot-starter-data-jpa</code>等。</p>

<p>传统的Spring Web应用打包之后需要放在Tomcat/Jetty容器下面运行，Spring Boot应用引入<code class="highlighter-rouge">spring-boot-starter-web</code>依赖之后还会引入一个内嵌的Tomcat，这个内嵌的Tomcat可以通过调用<code class="highlighter-rouge">SpringApplication.run()</code>再借助Spring Boot的自动配置启动。这样我们编写一个入口main函数，就可以直接启动Web应用了，无论是命令行、IDE、亦或打成一个独立的jar包用<code class="highlighter-rouge">java -jar</code>运行。</p>

<p>Spring Boot在减少配置方面还做了很多细的调优。比如对于ORM，一个Java entity类对应到数据库的一张表的时候，默认Java entity类的字段名对应到数据库的字段名。如果JPA用的是Hibernate，并且配置了<code class="highlighter-rouge">ImprovedNamingStrategy</code>，就可以把entity类里的camelCase的字段名映射到数据库表里snake_case的字段名，很有Convention Over Configuration的范儿了，但是对于外键却是不生效的。Spring Boot提供了一个<code class="highlighter-rouge">SpringNamingStrategy</code>继承<code class="highlighter-rouge">ImprovedNamingStrategy</code>，添加了对外键的支持。</p>

<h3 id="section">一些细节</h3>
<blockquote>
  <p>不要在意那些细节！</p>

  <p>  <span style="float:right; margin-right:10%">—— Coney Wu</span></p>
</blockquote>

<p>Spring 自动装配（autowire）就是自动发现匹配的bean注入到有依赖的bean里面去。所谓自动发现，就是Spring扫描ApplicationContext。所谓匹配，有两种，一种是byName——有依赖的bean的属性名字和被依赖的bean名字相同；另一种是byType——有依赖的bean的属性类型和被依赖的bean类型相同，当有多个同一类型的bean的时候，就会抛exception。@Autowired annotation是byType匹配的，如果有多个同类型的bean，可以结合@Qualifier annotation<sup>[<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-autowired-annotation-qualifiers">5</a>]</sup>指定到特定的bean上。</p>

<p>如果bean之间互相依赖，或者出现环会不会报错？——如果整条环上的bean之间都是<u>构造函数依赖注入</u>的方式互相依赖的话就会报错，前面实例代码里的注入方式即<u>构造函数依赖注入</u>，这种依赖注入方式表明要想实例化class A，必须先注入class B的实例化bean，如果class B也构造函数注入依赖于class A，那么就陷入死循环了。解决方法是把Spring启动先初始化的那个bean的<u>构造函数依赖注入</u>换成基于setter函数的依赖注入，或者用<code class="highlighter-rouge">@Autowired</code>注入到类的字段。但是通常情况下我们又不想去关心/控制bean的初始化顺序，这时候全部用setter函数注入或者用<code class="highlighter-rouge">@Autowired</code>注入类字段就是比较省心的方案。</p>

<p>Web容器和Web应用交互的入口点是一个称为deployment descriptor file的文件，即web.xml，再WEB-INF/文件夹下面，它定义了诸如servlet、servlet和URL的mapping、event listeners等</p>

<p>Java对象到JSON的相互转换只是属于Java和HTTP req/res相互转换中的一种，转换方法都继承于<code class="highlighter-rouge">HttpMessageConverter&lt;T&gt;</code>接口。在Spring里注册有有多个实现类，JSON的转换是由<code class="highlighter-rouge">MappingJackson2HttpMessageConverter</code>完成的，依赖于Jackson。</p>

<p>Spring Boot的另一个消灭手动配置的重要手法是自动配置，即根据应用现在CLASSPATH里的依赖的jar自动配置Spring，用<code class="highlighter-rouge">@EnableAutoConfiguration</code>注解开启，对Spring Boot来说几乎也是必须的。</p>

<p>Spring Boot应用有一个入口类标记了<code class="highlighter-rouge">@Configuration</code>。还有一个静态的main方法作为程序的入口，main方法再调用<code class="highlighter-rouge">SpringApplication</code>，把当前类作为入口配置传参数进去，<code class="highlighter-rouge">SpringApplication</code>再去启动内嵌tomcat等后续过程。</p>

<h3 id="further-reading">Further Reading</h3>

<p>这篇文章对Spring做了一个很基本的介绍，略去了很多的细节，Spring的官方文档提供了更全面和详细的阐述<sup>[<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/">0</a>]</sup>。Spring的模块/项目/子框架很多，除了我介绍的这三个，还有如切面编程的Spring AOP，Authentication和Authorization的框架Spring Security等等都是易学好用的车轮子。Spring Boot除了我上述的几个特性以外也还有很多值得关注的内容，如Spring Initializer、用于生产环境监控的actuator等等，一切的一切，都在Spring的官方文档里。</p>

<p><br /></p>

<p>参考资料：</p>

<ul>
  <li>https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html</li>
  <li>http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html</li>
  <li>http://docs.spring.io/spring-data/jpa/docs/current/reference/html</li>
  <li>http://sivalabs.in/2015/06/a-developers-perspective-on-spring-vs-javaee.html</li>
  <li>[0]http://docs.spring.io/spring/docs/current/spring-framework-reference/html/</li>
  <li>[1]https://tools.ietf.org/html/rfc6570</li>
  <li>[2]https://spring.io/projects</li>
  <li>[3]http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation</li>
  <li>[4]http://post.lxd.me/2015-12-07-spring-data-jpa-internals/</li>
  <li>[5]http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-autowired-annotation-qualifiers</li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
